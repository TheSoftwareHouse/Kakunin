{
    "docs": [
        {
            "location": "/", 
            "text": "About Kakunin\n\n\nKakunin is a Protractor extension created by The Software House sp. z o.o. and Takamol Holding. It allows you\nto write e2e test scenarios with a help of Gherkin language and JavaScript for all kind of applications - Angular, React and others.\n\n\nInstallation\n\n\nIn order to install Kakunin you have to make sure that you have installed:\n\n\nnode.js - v7.8.0 min\nJDK\nChrome\n\n\n\n\n\nCreate directory for your project \nmkdir my_project\n\n\nGo to project directory \ncd my_project\n\n\nInitialize JavaScript project by typing \nnpm init\n\n\nOpen \npackage.json\n file and add required dev dependencies:\n\n\n\n\nwebdriver-manager\n: \n12.0.6\n,\n\nprotractor\n: \n5.1.2\n,\n\nkakunin\n: \ngit+ssh://git@bitbucket.org/thesoftwarehouse/e2e-pascal.git#fixes\n\n\n\n\n\n\n\nIn \npackage.json\n add new script in \nscripts\n section:\n\n\n\n\nkakunin\n: \nNODE_ENV=prod kakunin\n\n\n\n\n\n\n\nInstall dependencies \nnpm install\n\n\nCreate kakunin project \nnpm run kakunin init\n\n\nAnswer what kind of app you're going to test (\ndefault: NG1\n)\n\n\nFill url for your app (\ndefault: http://localhost:3000\n)\n\n\nAre you going to use some emails checking service ? (\ndefault: none\n)\n\n\nRun Kakunin's testing features \nnpm run kakunin\n\n\n\n\nYou're read to use Kakunin.\n\n\nTips\n\n\nIn order to use autosuggest functionality in JETBrains tools, make sure your project is \nECMAScript 6\n compatible and you have \ncucumberjs\n plugin installed.\n\n\nIf it is, go to \nstep_definitions\n directory \ncd step_definitions\n and paste this code into terminal and restart your IDE:\n\n\nln -s ../node_modules/kakunin/dist/step_definitions/elements.js kakunin-elements.js\nln -s ../node_modules/kakunin/dist/step_definitions/debug.js kakunin-debug.js\nln -s ../node_modules/kakunin/dist/step_definitions/file.js kakunin-file.js\nln -s ../node_modules/kakunin/dist/step_definitions/form.js kakunin-form.js\nln -s ../node_modules/kakunin/dist/step_definitions/email.js kakunin-email.js\nln -s ../node_modules/kakunin/dist/step_definitions/generators.js kakunin-generators.js\nln -s ../node_modules/kakunin/dist/step_definitions/navigation.js kakunin-navigation.js \n\n\n\n\nThis will create symlinks inside \nstep_definitions\n directory and make \ncucumberjs\n plugin recognize kakunin built-in steps.\n\n\nCommands\n\n\n\n\nnpm run kakunin init [-- --advanced]\n - Create a new project by answering few simple questions (you can pass additional parameter to enter advanced mode where you can configure all Kakunin options by yourself)\n\n\nnpm run kakunin\n - Run test scenarios\n\n\nnpm run kakunin -- --tags @someTag\n - Run only scenarios tagged by \n@someTag\n\n\nnpm run kakunin -- --tags \"@someTag and @otherTag\"\n - Run only scenarios tagged by \n@someTag\n and \n@otherTag\n at the same time\n\n\nnpm run kakunin -- --tags \"@someTag or @otherTag\"\n - Run only scenarios tagged by \n@someTag\n or \n@otherTag\n\n\nnpm run kakunin -- --tags \"not @someTag\"\n - Run only scenarios not tagged by \n@someTag", 
            "title": "Getting started"
        }, 
        {
            "location": "/#about-kakunin", 
            "text": "Kakunin is a Protractor extension created by The Software House sp. z o.o. and Takamol Holding. It allows you\nto write e2e test scenarios with a help of Gherkin language and JavaScript for all kind of applications - Angular, React and others.", 
            "title": "About Kakunin"
        }, 
        {
            "location": "/#installation", 
            "text": "In order to install Kakunin you have to make sure that you have installed:  node.js - v7.8.0 min\nJDK\nChrome   Create directory for your project  mkdir my_project  Go to project directory  cd my_project  Initialize JavaScript project by typing  npm init  Open  package.json  file and add required dev dependencies:   webdriver-manager :  12.0.6 , protractor :  5.1.2 , kakunin :  git+ssh://git@bitbucket.org/thesoftwarehouse/e2e-pascal.git#fixes    In  package.json  add new script in  scripts  section:   kakunin :  NODE_ENV=prod kakunin    Install dependencies  npm install  Create kakunin project  npm run kakunin init  Answer what kind of app you're going to test ( default: NG1 )  Fill url for your app ( default: http://localhost:3000 )  Are you going to use some emails checking service ? ( default: none )  Run Kakunin's testing features  npm run kakunin   You're read to use Kakunin.", 
            "title": "Installation"
        }, 
        {
            "location": "/#tips", 
            "text": "In order to use autosuggest functionality in JETBrains tools, make sure your project is  ECMAScript 6  compatible and you have  cucumberjs  plugin installed.  If it is, go to  step_definitions  directory  cd step_definitions  and paste this code into terminal and restart your IDE:  ln -s ../node_modules/kakunin/dist/step_definitions/elements.js kakunin-elements.js\nln -s ../node_modules/kakunin/dist/step_definitions/debug.js kakunin-debug.js\nln -s ../node_modules/kakunin/dist/step_definitions/file.js kakunin-file.js\nln -s ../node_modules/kakunin/dist/step_definitions/form.js kakunin-form.js\nln -s ../node_modules/kakunin/dist/step_definitions/email.js kakunin-email.js\nln -s ../node_modules/kakunin/dist/step_definitions/generators.js kakunin-generators.js\nln -s ../node_modules/kakunin/dist/step_definitions/navigation.js kakunin-navigation.js   This will create symlinks inside  step_definitions  directory and make  cucumberjs  plugin recognize kakunin built-in steps.", 
            "title": "Tips"
        }, 
        {
            "location": "/#commands", 
            "text": "npm run kakunin init [-- --advanced]  - Create a new project by answering few simple questions (you can pass additional parameter to enter advanced mode where you can configure all Kakunin options by yourself)  npm run kakunin  - Run test scenarios  npm run kakunin -- --tags @someTag  - Run only scenarios tagged by  @someTag  npm run kakunin -- --tags \"@someTag and @otherTag\"  - Run only scenarios tagged by  @someTag  and  @otherTag  at the same time  npm run kakunin -- --tags \"@someTag or @otherTag\"  - Run only scenarios tagged by  @someTag  or  @otherTag  npm run kakunin -- --tags \"not @someTag\"  - Run only scenarios not tagged by  @someTag", 
            "title": "Commands"
        }, 
        {
            "location": "/configuration/", 
            "text": "Kakunin config\n\n\nmodule.exports = {\n    \nbrowserWidth\n: 1600,\n    \nbrowserHeight\n: 900,\n    \ntimeout\n: 60,\n    \nelementsVisibilityTimeout\n: 5,\n    \nwaitForPageTimeout\n: 5,\n    \ndownloadTimeout\n: 30,\n    \nreports\n: \n/reports\n,\n    \ndownloads\n: \n/downloads\n,\n    \ndata\n: \n/data\n,\n    \nfeatures\n: [\n        \n/features\n\n    ],\n    \npages\n: [\n        \n/pages\n\n    ],\n    \nmatchers\n: [\n        \n/matchers\n\n    ],\n    \ngenerators\n: [\n        \n/generators\n\n    ],\n    \nform_handlers\n: [\n        \n/form_handlers\n\n    ],\n    \nstep_definitions\n: [\n        \n/step_definitions\n\n    ],\n    \ncomparators\n: [\n        \n/comparators\n\n    ],\n    \ndictionaries\n: [\n        \n/dictionaries\n\n    ],\n    \ntransformers\n: [\n        \n/transformers\n\n    ],\n    \nregexes\n: [\n        \n/regexes\n\n    ],\n    \nhooks\n: [\n        \n/hooks\n\n    ],\n    \nclearEmailInboxBeforeTests\n: false,\n    \nclearCookiesAfterScenario\n: true,\n    \nclearLocalStorageAfterScenario\n: true,\n    \nemail\n: null,\n    \nheadless\n: false,\n    \nnoGpu\n: false,\n    \ntype\n: \notherWeb\n,\n    \nbaseUrl\n: \nhttp://localhost:8080\n,\n    \naccounts\n: {\n        \nsomeAccount\n: {\n            \naccounts\n: [\n                {\n                    \nemail\n: \n,\n                    \npassword\n: \n\n                }\n            ]\n        }\n    }\n}\n\n\n\n\n\nConfiguration options\n\n\nbrowserWidth\n - width of browser window \ndefault: 1600\n\n\nbrowserheight\n - height of browser window \ndefault: 900\n\n\ntimeout\n - global timeout for a single step execution in seconds \ndefault: 60\n\n\nintervalEmail\n - interval for email checking step \ndefault: 5\n in seconds\n\n\nelementsVisibilityTimeout\n - maximum wait timeout for element visibility \ndefault: 5\n seconds\n\n\nwaitForPageTimeout\n - maximum wait timeout for page visibility \ndefault: 5\n seconds\n\n\ndownloadTimeout\n - maximum wait timeout for file to be downloaded \ndefault: 30\n seconds\n\n\nemails\n - array of paths to store emails related custom code\n\n\nreports\n - path to store reports\n\n\ndownloads\n - path to store downloaded files\n\n\ndata\n - path to store test related files (for example files to be downloaded)\n\n\nfeature\n - array of paths to store features\n\n\npages\n - array of paths to store page objects\n\n\nmatchers\n - array of paths to store custom matchers\n\n\ngenerators\n - array of paths to store custom generators\n\n\nform_handlers\n - array of paths to store custom form handlers\n\n\nstep_definitions\n - array of paths to store custom steps\n\n\ncomparators\n - array of paths to store custom comparators\n\n\ndictionaries\n - array of paths to store custom dictionaries\n\n\ntransformers\n - array of paths to store custom transformers\n\n\nregexes\n - array of paths to store custom regexes\n\n\nhooks\n - array of paths to store custom hooks\n\n\nclearEmailInboxBeforeTests\n - flag to active clearing email inbox before tests are executed \ndefault: false | true for apps with email checking functionality activated\n\n\nclearCookiesAfterScenario\n - flag to activate clearing cookies after every scenario \ndefault: true\n\n\nclearLocalStorageAfterScenario\n - flag to activate clearing local storage after every scenario \ndefault: true\n\n\nemail\n - email configuration \ndefault: null\n\n\nfor mailtrap email checking system:\n\n\ntype\n: \nmailtrap\n,\n\nconfig\n: {\n    \napiKey\n: \nyour-mailtrap-api-key\n,\n    \ninboxId\n: \nyour-mailtrap-inbox\n,\n    \nurl\n: \nhttps://mailtrap.io/api/v1\n\n}\n\n\n\n\nfor custom email checking system only type is required:\n\n\ntype\n: \ncustom-type\n\n\n\n\n\nheadless\n - flag to activate chrome headless browser \ndefault: false\n\n\nnoGpu\n - flag to activate cpu only mode \ndefault: false\n\n\ntype\n - type of application either \nng1 | ng2 | otherWeb\n\n\nbaseUrl\n - url of tested application\n\n\naccounts\n - object to store accounts information. This is bound to \nuserProvider\n and allows to use advanced email checking options like recipient checking.\n\n\nsomeAccount\n: {\n    \naccounts\n: [\n        {\n            \nemail\n: \n,\n            \npassword\n: \n\n        }\n    ]\n}\n\n\n\n\nEnvironment variables\n\n\nKakunin uses a single \n.env\n file to load ENV variables. By default there is only one:\n\n\nFIXTURES_RELOAD_HOST\n - allows you to specify host for fixtures reloading. This allows you to use \n@reloadFixtures\n tag on scenarios that should restore database to starting state, before the test is running", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#kakunin-config", 
            "text": "module.exports = {\n     browserWidth : 1600,\n     browserHeight : 900,\n     timeout : 60,\n     elementsVisibilityTimeout : 5,\n     waitForPageTimeout : 5,\n     downloadTimeout : 30,\n     reports :  /reports ,\n     downloads :  /downloads ,\n     data :  /data ,\n     features : [\n         /features \n    ],\n     pages : [\n         /pages \n    ],\n     matchers : [\n         /matchers \n    ],\n     generators : [\n         /generators \n    ],\n     form_handlers : [\n         /form_handlers \n    ],\n     step_definitions : [\n         /step_definitions \n    ],\n     comparators : [\n         /comparators \n    ],\n     dictionaries : [\n         /dictionaries \n    ],\n     transformers : [\n         /transformers \n    ],\n     regexes : [\n         /regexes \n    ],\n     hooks : [\n         /hooks \n    ],\n     clearEmailInboxBeforeTests : false,\n     clearCookiesAfterScenario : true,\n     clearLocalStorageAfterScenario : true,\n     email : null,\n     headless : false,\n     noGpu : false,\n     type :  otherWeb ,\n     baseUrl :  http://localhost:8080 ,\n     accounts : {\n         someAccount : {\n             accounts : [\n                {\n                     email :  ,\n                     password :  \n                }\n            ]\n        }\n    }\n}", 
            "title": "Kakunin config"
        }, 
        {
            "location": "/configuration/#configuration-options", 
            "text": "browserWidth  - width of browser window  default: 1600  browserheight  - height of browser window  default: 900  timeout  - global timeout for a single step execution in seconds  default: 60  intervalEmail  - interval for email checking step  default: 5  in seconds  elementsVisibilityTimeout  - maximum wait timeout for element visibility  default: 5  seconds  waitForPageTimeout  - maximum wait timeout for page visibility  default: 5  seconds  downloadTimeout  - maximum wait timeout for file to be downloaded  default: 30  seconds  emails  - array of paths to store emails related custom code  reports  - path to store reports  downloads  - path to store downloaded files  data  - path to store test related files (for example files to be downloaded)  feature  - array of paths to store features  pages  - array of paths to store page objects  matchers  - array of paths to store custom matchers  generators  - array of paths to store custom generators  form_handlers  - array of paths to store custom form handlers  step_definitions  - array of paths to store custom steps  comparators  - array of paths to store custom comparators  dictionaries  - array of paths to store custom dictionaries  transformers  - array of paths to store custom transformers  regexes  - array of paths to store custom regexes  hooks  - array of paths to store custom hooks  clearEmailInboxBeforeTests  - flag to active clearing email inbox before tests are executed  default: false | true for apps with email checking functionality activated  clearCookiesAfterScenario  - flag to activate clearing cookies after every scenario  default: true  clearLocalStorageAfterScenario  - flag to activate clearing local storage after every scenario  default: true  email  - email configuration  default: null  for mailtrap email checking system:  type :  mailtrap , config : {\n     apiKey :  your-mailtrap-api-key ,\n     inboxId :  your-mailtrap-inbox ,\n     url :  https://mailtrap.io/api/v1 \n}  for custom email checking system only type is required:  type :  custom-type   headless  - flag to activate chrome headless browser  default: false  noGpu  - flag to activate cpu only mode  default: false  type  - type of application either  ng1 | ng2 | otherWeb  baseUrl  - url of tested application  accounts  - object to store accounts information. This is bound to  userProvider  and allows to use advanced email checking options like recipient checking.  someAccount : {\n     accounts : [\n        {\n             email :  ,\n             password :  \n        }\n    ]\n}", 
            "title": "Configuration options"
        }, 
        {
            "location": "/configuration/#environment-variables", 
            "text": "Kakunin uses a single  .env  file to load ENV variables. By default there is only one:  FIXTURES_RELOAD_HOST  - allows you to specify host for fixtures reloading. This allows you to use  @reloadFixtures  tag on scenarios that should restore database to starting state, before the test is running", 
            "title": "Environment variables"
        }, 
        {
            "location": "/how-it-works/", 
            "text": "Kakunin is built with \nno-js\n experience in mind. Because of that you're able to test even complicated apps just\nby knowing Kakunin steps and a few good practices.\n\n\nConcepts\n\n\nKakunin uses \ncucumber-js\n internally, because of that all tests (or rather scenarios) are using \nGherkin\n as a \"programming\"\nlanguage.\n\n\nA simple scenario could look like this:\n\n\nFeature:\n    Scenario: Display user profile for logged user\n        Given I am logged in as a \nuser\n\n        When the \ndashboard\n page is displayed\n        And I click the \nprofileButton\n element\n        Then the \nmyProfile\n page is displayed\n        And the \nmyName\n element is visible\n\n\n\n\nThis is how most of Kakunin test scenarios look like.\n\n\nThere are a few concepts to be explained.\n\n\nPage objects\n\n\nPage object is a code representation of a page displayed in browser. Kakunin has a two type of page objects built-in:\n\n\n\n\nBasePage\n - for all kind of pages that do not have any kind of a form\n\n\nFormPage\n - the same as \nBasePage\n + support for form interactions\n\n\n\n\nIn your code, you're going to create own page objects, that will extend one of Kakunin's.\n\n\nWe recommend to use \nFormPage\n as the one you're going to extend.\n\n\nPage object contains information about page url, its elements, locators, but can also have some custom methods if necessary.\n\n\nA very simple Kakunin's page object could look like this.\n\n\nconst { FormPage } = require('kakunin');\n\nclass DashboardPage extends FromPage {\n    constructor() {\n        super();\n\n        this.url = '/dashboard';\n        this.isExternal = false; // optional\n    }\n}\n\nmodule.exports = new DashboardPage();\n\n\n\n\nAs you see a basic page object must extend one of Kakunin's and have to have url defined \nthis.url\n.\n\n\nOptionally if the page is a main page to be displayed then for \nng1\n and \nng2\n apps you have to provider \nthis.isExternal = true;\n flag.\n\n\nThis code should be saved inside \npages\n directory in a file with \njs\n extension. What is important is a name of this file, because we're going to use it\nas parameter for steps, for example \nWhen the \"dashboard\" page is displayed\n expects that there is a file named \ndashboard.js\n inside the \npages\n directory. \n\n\nEvery step that we are using is somehow connected to a object called \ncurrentPage\n. This object value is set to a \npage object that we expect to be on.\n\n\nThis is done by two kind of steps:\n\n\n\n\nthe \"dashboard\" page is displayed\n - this one checks if current url in browser is the same as the one inside page object and changes a value of \ncurrentPage\n\n to this page object\n\n\nI visit the \"dashboard\" page\n - this one goes to the url specified in page object and sets the \ncurrentPage\n to that page object\n\n\n\n\nThis concept is a very simple one and allows you to easily debug the Kakunin. You can assume that every step that is below one of this methods is executed in context of a page object specified in those methods.\nFor example if we have such code:\n\n\nFeature:\n    Scenario: Display user profile for logged user\n        Given I am logged in as a \nuser\n\n        When the \ndashboard\n page is displayed\n        And I click the \nprofileButton\n element\n        Then the \nmyProfile\n page is displayed\n        And the \nmyName\n element is visible\n\n\n\n\nAnd I click the \"profileButton\" element\n is executed in context of \ndashboard\n page objects. So we can assume that \nprofileButton\n should be defined inside the\n\ndashboard.js\n file.\n\n\nAt the same time \nAnd the \"myName\" element is visible\n is executed in context of \nmyProfile\n, so \nmyName\n should be inside \nmyProfile.js\n.\n\n\nElements and locators\n\n\nThe second concept that you have to understand are elements and locators.\n\n\nEvery element that you see on website can be represented as a element inside the page object. This allows us to use it as a parameter for a step, as we did in:\n\nAnd the \"myName\" element is visible\n.\n\n\nDefining elements is very simple. Let's say we have such page object:\n\n\nconst { FormPage } = require('kakunin');\n\nclass DashboardPage extends FromPage {\n    constructor() {\n        super();\n\n        this.url = '/dashboard';\n        this.isExternal = false; // optional\n    }\n}\n\nmodule.exports = new DashboardPage();\n\n\n\n\nElements should be defined inside \nconstructor\n method. Let's add element for \nmyName\n:\n\n\nconst { FormPage } = require('kakunin');\n\nclass DashboardPage extends FromPage {\n    constructor() {\n        super();\n\n        this.url = '/dashboard';\n        this.isExternal = false; // optional\n\n        this.myName = element(by.css('.myName'));\n    }\n}\n\nmodule.exports = new DashboardPage();\n\n\n\n\nAs you see we added a single line \nthis.myName = element(by.css('.myName'));\n.\n\n\nby.css('.myName')\n - is a locator, this is a standard protractor syntax, you can read more on protractors documentation\n\n\nBy joining \nelement\n method with a locator, we created element to be used by our steps.", 
            "title": "How it works"
        }, 
        {
            "location": "/how-it-works/#concepts", 
            "text": "Kakunin uses  cucumber-js  internally, because of that all tests (or rather scenarios) are using  Gherkin  as a \"programming\"\nlanguage.  A simple scenario could look like this:  Feature:\n    Scenario: Display user profile for logged user\n        Given I am logged in as a  user \n        When the  dashboard  page is displayed\n        And I click the  profileButton  element\n        Then the  myProfile  page is displayed\n        And the  myName  element is visible  This is how most of Kakunin test scenarios look like.  There are a few concepts to be explained.", 
            "title": "Concepts"
        }, 
        {
            "location": "/how-it-works/#page-objects", 
            "text": "Page object is a code representation of a page displayed in browser. Kakunin has a two type of page objects built-in:   BasePage  - for all kind of pages that do not have any kind of a form  FormPage  - the same as  BasePage  + support for form interactions   In your code, you're going to create own page objects, that will extend one of Kakunin's.  We recommend to use  FormPage  as the one you're going to extend.  Page object contains information about page url, its elements, locators, but can also have some custom methods if necessary.  A very simple Kakunin's page object could look like this.  const { FormPage } = require('kakunin');\n\nclass DashboardPage extends FromPage {\n    constructor() {\n        super();\n\n        this.url = '/dashboard';\n        this.isExternal = false; // optional\n    }\n}\n\nmodule.exports = new DashboardPage();  As you see a basic page object must extend one of Kakunin's and have to have url defined  this.url .  Optionally if the page is a main page to be displayed then for  ng1  and  ng2  apps you have to provider  this.isExternal = true;  flag.  This code should be saved inside  pages  directory in a file with  js  extension. What is important is a name of this file, because we're going to use it\nas parameter for steps, for example  When the \"dashboard\" page is displayed  expects that there is a file named  dashboard.js  inside the  pages  directory.   Every step that we are using is somehow connected to a object called  currentPage . This object value is set to a \npage object that we expect to be on.  This is done by two kind of steps:   the \"dashboard\" page is displayed  - this one checks if current url in browser is the same as the one inside page object and changes a value of  currentPage \n to this page object  I visit the \"dashboard\" page  - this one goes to the url specified in page object and sets the  currentPage  to that page object   This concept is a very simple one and allows you to easily debug the Kakunin. You can assume that every step that is below one of this methods is executed in context of a page object specified in those methods.\nFor example if we have such code:  Feature:\n    Scenario: Display user profile for logged user\n        Given I am logged in as a  user \n        When the  dashboard  page is displayed\n        And I click the  profileButton  element\n        Then the  myProfile  page is displayed\n        And the  myName  element is visible  And I click the \"profileButton\" element  is executed in context of  dashboard  page objects. So we can assume that  profileButton  should be defined inside the dashboard.js  file.  At the same time  And the \"myName\" element is visible  is executed in context of  myProfile , so  myName  should be inside  myProfile.js .", 
            "title": "Page objects"
        }, 
        {
            "location": "/how-it-works/#elements-and-locators", 
            "text": "The second concept that you have to understand are elements and locators.  Every element that you see on website can be represented as a element inside the page object. This allows us to use it as a parameter for a step, as we did in: And the \"myName\" element is visible .  Defining elements is very simple. Let's say we have such page object:  const { FormPage } = require('kakunin');\n\nclass DashboardPage extends FromPage {\n    constructor() {\n        super();\n\n        this.url = '/dashboard';\n        this.isExternal = false; // optional\n    }\n}\n\nmodule.exports = new DashboardPage();  Elements should be defined inside  constructor  method. Let's add element for  myName :  const { FormPage } = require('kakunin');\n\nclass DashboardPage extends FromPage {\n    constructor() {\n        super();\n\n        this.url = '/dashboard';\n        this.isExternal = false; // optional\n\n        this.myName = element(by.css('.myName'));\n    }\n}\n\nmodule.exports = new DashboardPage();  As you see we added a single line  this.myName = element(by.css('.myName')); .  by.css('.myName')  - is a locator, this is a standard protractor syntax, you can read more on protractors documentation  By joining  element  method with a locator, we created element to be used by our steps.", 
            "title": "Elements and locators"
        }, 
        {
            "location": "/steps/", 
            "text": "Navigation\n\n\nI visit the \":pageFileName\" page\n\n\nVisits the url of the page object with \n:pageFileName\n name.\n\n\nIn order to make it work we create a page object file with a name of \n:pageFileName\n.\n\n\nFor example in case of: \nI visit the \"myPage\" page\n there should be a file \nmyPage.js\n inside the \npages\n directory.\n\n\nIf we have a page object with a name \nsomePageObject.js\n defined inside \npages\n directory then:\n\n\nGiven I visit the \"somePageObject\" page\n\n\nwill set \nthis.currentPage\n variable to \nsomePageObject\n page and we should end up on \nsomePageObject\n url.\n\n\nI visit the \":pageFileName\" page with parameters:\n\n\nThe same as \nI visit the \":pageFileName\" page\n except allows to pass url parameters.\n\n\nIf url of \nmyPage\n is defined as \nthis.url = /orders/:orderId/products/:productId\n then we can use this step to visit this page by:\n\n\nI visit the \nmyPage\n page with parameters:\n    | orderId   | 1 |\n    | productId | 2 |\n\n\n\n\nthis will result in visiting the \n/orders/1/product/2\n page.\n\n\nthe \":pageFileName\" page is displayed\n\n\nChecks if current browser url matches url of \npageFileName\n page object. \n\n\nIf the url matches expected pattern then \n\nthis.currentPage\n variable is set to \npageFileName\n page object.\n\n\nForms\n\n\nI fill the \":formName\" form with:\n\n\nAllows to fill the form with the name \n:formName\n and values provided as an array of inputs and values. The element with name \n:formName\n must be defined inside the \n\ncurrentPage\n page object.\n\n\nInput and values should be provided as an array for example:\n\n\nI fill the \nmyForm\n form with:\n  | inputElement    | value to be typed into field        |\n  | textareaElement | value to be typed into textarea     |\n  | radioElement    | radio value to be selected          |\n  | checkboxElement | checkbox label value to be selected |\n\n\n\n\nBy default we support all basic HTML field types (text inputs, checkboxes, radios, selects, files and textareas)\n\n\nIn order to use the default handlers the elements you use as input must follow pattern:\n\n\nFor inputs:\n\n\nthis.element = $('input')\n - element should point at input you want to fill\n\n\nFor textareas:\n\n\nthis.element = $('textarea')\n - element should point at textarea you want to fill\n\n\nFor file input:\n\n\nthis.element = $('input')\n - element should point at input you want to fill and value should a filename of file from \ndata\n directory\n\n\nFor selects:\n\n\nthis.element = $('select')\n - element should point at select and value should be an value of expected option\n\n\nFor radios:\n\n\nthis.element = $$('radio[name=\"name-of-radio\"]')\n - element should be an array of all radio input of given name and value should be an value of radio you wish to select\n\n\nFor checkboxes:\n\n\nCheckbox should have a html like:\n\n\nlabel\n\n  My checkbox\n  \ninput type=\ncheckbox\n name=\nsome-name\n/\n\n\n/label\n  \n\n\n\n\nthis.element = $$('checkbox[name=\"name-of-radio\"]')\n - element should be an array of all checkboxes of given name and value should be a text from label of checkbox you want to fill\n\n\nYou can use all kind of transformers to as a values for fields.\n\n\nthe \":formName\" form is filled with:\n\n\nThe same as \nI fill the \":formName\" form with:\n but allows to check if a form is filled with a given set of values.\n\n\nYou can use all kind of transformers to as a expected values for fields.\n\n\nThe only difference is for file fields. You cannot check uploaded files just like that, however we prepared a special type of handler\nthat allow to check for some information related to a specific file.\n\n\nLet's assume that after upload we display an information with a file name of a uploaded file.\n\n\nYou can use a special handler that requires to set a element with a postfix \nUploaded\n. This will check if a value of that element is the same as you expected.\n\n\nFor example you can write a step like this:\n\n\nthe \nmyform\n form is filled with:\n  | myFileUploaded | file.txt |\n\n\n\n\nKeep in mind that the element name must end with \nUploaded\n for example:\n\n\nthis.myFileUploaded = $('p.some-file')\n\n\nthe error messages should be displayed:\n\n\nAllows you to specify the error messages that should be displayed for a specific elements.\n\n\nThis step requires an array of format:\n\n\nthe error messages should be displayed:\n  | element   | errorMessage     |\n  | myElement | my error message |\n\n\n\n\nKeep in mind that first row of array must be \n| element | errorMessage |\n.\n\n\nYou can use dictionaries in this step as follows:\n\n\nthe error messages should be displayed:\n  | element   | errorMessage                   |\n  | myElement | d:dictionaryName:dictionaryKey |\n\n\n\n\nElements\n\n\nI wait for \":expectedConditionName\" of the \":elementName\" element\n\n\nWaits till element \n:elementName\n from \nthis.currentPage\n meets criteria specified by \n:expectedConditionName\n.\n\n\nYou can use any of the Protractor's expected condition:\n\n\n\n\nvisibilityOf\n\n\ninvisibilityOf\n\n\n\n\netc.\n\n\nRead more in Protractor's API documentation.\n\n\nI wait for the \":elementName\" element to disappear\n\n\nWaits till element \n:elementName\n disappears.\n\n\nI scroll to the \":elementName\" element\n\n\nScrolls to element \n:elementName\n of \nthis.currentPage\n. The element will be on bottom of the page.\n\n\nI infinitely scroll to the \":elementName\" element\n\n\nAllows to scroll till \n:elementName\n is visible. Useful for infinite scrolling functionality.\n\n\nI press the \":keyName\" key\n\n\nPerforms a key press operation on \n:keyName\n key.\n\n\nI click the \":elementName\" element\n\n\nPerforms a click action on element \n:elementName\n from `this.currentPage'\n\n\nI click the \":elementName\" element if it is visible\n\n\nConditionally clicks on element \n:elementName\n of \nthis.currentPage\n only if it is visible.\n\n\nI click the \":elementName\" on the first item of \":containerElementName\" element\n\n\nAllows to click on the first child element of \n:containerElementName\n specified in \nthis.currentName\n.\n\n\nThe child element must be specified by \n:elementName\n nd must be available in \nthis.currentPage\n\n\nI store the \":elementName\" element text as \":variableName\" variable\n\n\nStores the text from element \n:elementName\n of \nthis.currentPage\n under the \n:variableName\n so you can use it later.\n\n\nI update the \":elementName\" element text as \":variableName\" variable\n\n\nUpdates the variable \n:variableName\n value by value from element \n:elementName\n of \nthis.currentPage\n.\n\n\nI store the \":elementName\" element text matched by \":matchingRegex\" as \":variableName\" variable\n\n\nStores the part of the element \n:elementName\n text, that matches the \n:matchingRegex\n under the \n:variableName\n for later use.\n\n\nthe \":elementName\"\" element is present\n\n\nChecks if element \n:elementName\n is available in HTML DOM\n\n\nthe \":elementName\"\" element is not present\n\n\nChecks if element \n:elementName\n is not available in HTML DOM\n\n\nthe \":elementName\"\" element is visible\n\n\nChecks if element \n:elementName\n is visible and clickable\n\n\nthe \":elementName\"\" element is not visible\n\n\nChecks if element \n:elementName\n is available in HTML DOM but is not visible and clickable\n\n\nthe \":elementName\" element is disabled\n\n\nChecks if element is disabled\n\n\nI store table \":tableElementName\" rows as \":variableName\" with columns:\n\n\nAllows to store a row specified columns from a table \n:tableElementName\n and save it under \n:variableName\n as an array of objects.\n\n\nThis step requires a table of columns locators, for example:\n\n\nI store table \nmyTable\n rows as \nsomeVariable\n with columns:\n  | firstName |\n  | lastName  |\n  | id        |\n\n\n\n\nIn order to make it work there must be not only element \nmyTable\n in \nthis.currentPage\n, but also\nlocator \nthis.firstName = by.css('.firstName');\n and so on.\n\n\nThe result of this step is an array of:\n\n\n[\n  [\n    'firsRowFirstNameValue',\n    'firsRowLastNameValue'\n    'firsRowIdValue'\n  ]\n  ...\n]\n\n\n\n\nthere are following elements in table \":elementName\":\n\n\nAllows to check if a child elements of \n:elementName\n have a specified content.\n\n\nThis steps allows you to specify an array of child elements locators that will be checked against expected values.\n\n\nFor example:\n\n\nthere are following elements in table \nmyTable\n:\n  | id  | firstName | lastName |\n  | t:1 | t:Adam    | t:Doe    |\n  | t:2 | t:John    | t:Doe    |\n\n\n\n\nFirst row must specify columns locators. Starting from second row we must provider a matchers for each row that must be displayed.\n\n\nThis step checks exact match, so if the table has 5 rows, there must be a 5 rows in this table.\n\n\nWe can specify only a set of columns (for example if a table has 5 columns, we can specify only 1).\n\n\nthere are \"numberExpression\" following elements for element \":elementName\":\n\n\nAllows to check if a child elements of \n:elementName\n have a specified content. Element should be an array, for example:\n\n\ntable\n\n  \ntr\n\n    \ntd\n1\n/td\n\n  \n/tr\n\n  \ntr\n\n    \ntd\n2\n/td\n\n  \n/tr\n   \n\n/table\n\n\n\n\n\nfor this case the \n:elementName\n should be specified as \n$$('table tr')\n.\n\n\nAllows to check if a number of elements is the one that we expect.\n\n\nnumberExpression\n is a supported expression from \nchai.js\n library:\n\n\n\n\n\n\nequal N\n where N is a number\n\n\n\n\n\n\nat least N\n where N is a number\n\n\n\n\n\n\nabove N\n where N is a number\n\n\n\n\n\n\nbelow N\n where N is a number\n\n\n\n\n\n\nwithin N M\n where N and M are a numbers\n\n\n\n\n\n\nand so on. You can check expressions on \nchai.js\n API dock for BDD.\n\n\nThis step requires an array of elements locators to be checked. For example:\n\n\nthere are \nequal 5\n following elements for element \nmyList\n:\n  | element    | value         |\n  | viewButton | f:isClickable |\n  | id         | r:idRegex     |\n\n\n\n\nThe first row must be \n| element    | value |\n, after that we specify a list of element locators to be checked for each element of \n:elementName\n array.\n\n\nThe child elements must be a locators, for example \nthis.viewButton = by.css('button.viewButton');\n.\n\n\nYou can use all kind of matchers here.\n\n\nthere is element \":elementName\" with value \":matcher\"\n\n\nAllows to check if \n:elementName\n has a value that matches the \n:matcher\n.\n\n\nthere is no element \":elementName\" with value \":matcherName\"\n\n\nAllows to check if there is no \n:elementName\n that matches the \n:matcher\n.\n\n\nthere are \"numberExpression\" \":elementName\" elements\n\n\nAllows to check if a number of \n:elementName\n elements is the same as we expect.\n\n\nnumberExpression\n is a supported expression from \nchai.js\n library:\n\n\n\n\n\n\nequal N\n where N is a number\n\n\n\n\n\n\nat least N\n where N is a number\n\n\n\n\n\n\nabove N\n where N is a number\n\n\n\n\n\n\nbelow N\n where N is a number\n\n\n\n\n\n\nwithin N M\n where N and M are a numbers\n\n\n\n\n\n\nand so on. You can check expressions on \nchai.js\n API dock for BDD.\n\n\n:elementName\n should be specified as an array, for example:\n\n\ntable\n\n  \ntr\n\n    \ntd\n1\n/td\n\n  \n/tr\n\n  \ntr\n\n    \ntd\n2\n/td\n\n  \n/tr\n   \n\n/table\n\n\n\n\n\nfor this case the \n:elementName\n should be specified as \n$$('table tr')\n.\n\n\nevery \":elementName\" element should have the same value for element \":columnElementName\"\n\n\nAllows to check if every row defined by \n:elementName\n has the same value for a column \n:columnElementName\n.\n\n\n:elementName\n must be an array of elements\n\n\n:columnElementName\n must be an locator, for example:\n\n\ntable\n\n  \ntr\n\n    \ntd\n1\n/td\n\n  \n/tr\n\n  \ntr\n\n    \ntd\n1\n/td\n\n  \n/tr\n   \n\n/table\n\n\n\n\n\nfor this case the \n:elementName\n should be specified as \n$$('table tr')\n and we can specify column locator\n\nthis.myColumn = by.css('td');\n. This allows us to write:\n\n\nevery \"myElement\" element should have the same value for element \"myColumn\"\n\n\nevery \":elementName\" element should have the same value for element \":columnElementName\" attribute \":attributeName\"\n\n\nThe same as \nevery \":elementName\" element should have the same value for element \":columnElementName\"\n, but check if all cells have the same value for an\nattribute specified by \n:atrributeName\n.\n\n\n\":columnElementName\" value on the \":elementName\" list is sorted in \"ascending|descending\" order\n\n\nChecks if the values for column \n:columnElementName\n of each row specified by \n:elementName\n is sorted in either ascending or descending order.\n\n\n:columnElementName\n must be a locator used to get a column on each row of an array \n:elementName\n. For example:\n\n\ntable\n\n  \ntr\n\n    \ntd\n1\n/td\n\n  \n/tr\n\n  \ntr\n\n    \ntd\n2\n/td\n\n  \n/tr\n   \n\n/table\n\n\n\n\n\nThe \n:elementName\n should be specified as \nthis.myElement = $$('table tr')\n\n\nThe \n:columnElementName\n should be an locator \nthis.myColumn = by.css(td);\n.\n\n\nNow we can use this step to check the order of elements.\n\n\nEmails\n\n\nthe email has been sent and contains:\n\n\nChecks if there is an email on the configured mailing service.\n\n\nThis steps requires an array of filters to be applied to mailbox in order to find an email you're looking for.\n\n\nYou can do this like this:\n\n\nthe email has been sent and contains:\n| html_body | t:some value | | |\n\n\n\n\nThe number of columns is always 4, but depending form a filter you have to use all of them or only some.\n\n\nWe do support filtering by any property returned in MailTrap Api response format. Go check \nExtending Kakunin\n for more information.\n\n\nThere are 2 custom filters:\n\n\nthe email has been sent and contains:\n| currentUser | | | |\n\n\n\n\nThis one checks if the user saved in \nthis.currentUser\n variable is a recipient of an email. This is done by comparing \nemail\n property of \nthis.currentUser\n object to the one returned by email.\n\n\nthe email has been sent and contains:\n| file | t:fileName | r:fileExtension | sizeInBytes |\n\n\n\n\nThis one is looking for an attachment with a name matching \nt:fileName\n, extension matching \nr:fileExtension\n, \nsizeInBytes\n as a minimum bytes size.\n\n\nYou can use the same filter multiple times:\n\n\nthe email has been sent and contains:\n| file | t:fileName      | r:fileExtension | sizeInBytes |\n| file | t:otherfileName | r:fileExtension | sizeInBytes |\n\n\n\n\nThis will look for an email with 2 attachments.\n\n\nFiles\n\n\nthe file \":fileName\" should be downloaded\n\n\nChecks if a file with name \n:fileName\n was downloaded.\n\n\nThis step does not support matchers or regular expressions, so the name must be exact match. However you can use\nvariable store here.\n\n\nLet's assume there is a variable \nmyFile\n with a value \nsuper-file\n in variable store.\n\n\nYou can write \nthe file \"v:myFile.zip\" should be downloaded\n to check if a file \nsuper-file.zip\n was downloaded. \n\n\nthe file \":fileName\" contains table data stored under \":variableName\" variable\n\n\nThis step allows you to compare an xls/xlsx file \n:fileName\n with an existing data stored under \n:variableName\n variable.\n\n\nThe data under \n:variableName\n must be an array of objects representing each row of file. \n\n\nGenerators\n\n\nI generate random \":generatorName\" as \":variableName\"\n\n\nAllows to generate a random value using the generator specified by \n:generatorName\n.\n\n\nThe generator must be defined inside the any of the \ngenerators\n directories specified in \nkakunin.conf.js\n file \ndefault: generators\n.\n\n\nIf the generator exists, then the value will be saved under the \n:variableName\n and can be accessed by:\n\n\n\n\n\n\nsteps using variable store\n\n\n\n\n\n\nby calling \nvariableStore.getVariableValue(:variableName)\n\n\n\n\n\n\nby using variable store transformer on supported steps \nv:variableName\n\n\n\n\n\n\nI generate random \":generatorName\" \":generatorParamter\" as \":variableName\"\n\n\nThe same as \nI generate random \":generatorName\" as \":variableName\"\n but allows to pass additional parameter to generator.\n\n\nDebug\n\n\nI pause\n\n\nPauses tests execution and allows to continue manually by pressing combination of \nctrl+c\n inside terminal.\n\n\nI wait for \":seconds\" seconds\n\n\nWaits with execution of next step for an amount provided by parameter \n:seconds\n.", 
            "title": "Built-in steps"
        }, 
        {
            "location": "/steps/#navigation", 
            "text": "", 
            "title": "Navigation"
        }, 
        {
            "location": "/steps/#i-visit-the-pagefilename-page", 
            "text": "Visits the url of the page object with  :pageFileName  name.  In order to make it work we create a page object file with a name of  :pageFileName .  For example in case of:  I visit the \"myPage\" page  there should be a file  myPage.js  inside the  pages  directory.  If we have a page object with a name  somePageObject.js  defined inside  pages  directory then:  Given I visit the \"somePageObject\" page  will set  this.currentPage  variable to  somePageObject  page and we should end up on  somePageObject  url.", 
            "title": "I visit the \":pageFileName\" page"
        }, 
        {
            "location": "/steps/#i-visit-the-pagefilename-page-with-parameters", 
            "text": "The same as  I visit the \":pageFileName\" page  except allows to pass url parameters.  If url of  myPage  is defined as  this.url = /orders/:orderId/products/:productId  then we can use this step to visit this page by:  I visit the  myPage  page with parameters:\n    | orderId   | 1 |\n    | productId | 2 |  this will result in visiting the  /orders/1/product/2  page.", 
            "title": "I visit the \":pageFileName\" page with parameters:"
        }, 
        {
            "location": "/steps/#the-pagefilename-page-is-displayed", 
            "text": "Checks if current browser url matches url of  pageFileName  page object.   If the url matches expected pattern then  this.currentPage  variable is set to  pageFileName  page object.", 
            "title": "the \":pageFileName\" page is displayed"
        }, 
        {
            "location": "/steps/#forms", 
            "text": "", 
            "title": "Forms"
        }, 
        {
            "location": "/steps/#i-fill-the-formname-form-with", 
            "text": "Allows to fill the form with the name  :formName  and values provided as an array of inputs and values. The element with name  :formName  must be defined inside the  currentPage  page object.  Input and values should be provided as an array for example:  I fill the  myForm  form with:\n  | inputElement    | value to be typed into field        |\n  | textareaElement | value to be typed into textarea     |\n  | radioElement    | radio value to be selected          |\n  | checkboxElement | checkbox label value to be selected |  By default we support all basic HTML field types (text inputs, checkboxes, radios, selects, files and textareas)  In order to use the default handlers the elements you use as input must follow pattern:  For inputs:  this.element = $('input')  - element should point at input you want to fill  For textareas:  this.element = $('textarea')  - element should point at textarea you want to fill  For file input:  this.element = $('input')  - element should point at input you want to fill and value should a filename of file from  data  directory  For selects:  this.element = $('select')  - element should point at select and value should be an value of expected option  For radios:  this.element = $$('radio[name=\"name-of-radio\"]')  - element should be an array of all radio input of given name and value should be an value of radio you wish to select  For checkboxes:  Checkbox should have a html like:  label \n  My checkbox\n   input type= checkbox  name= some-name /  /label     this.element = $$('checkbox[name=\"name-of-radio\"]')  - element should be an array of all checkboxes of given name and value should be a text from label of checkbox you want to fill  You can use all kind of transformers to as a values for fields.", 
            "title": "I fill the \":formName\" form with:"
        }, 
        {
            "location": "/steps/#the-formname-form-is-filled-with", 
            "text": "The same as  I fill the \":formName\" form with:  but allows to check if a form is filled with a given set of values.  You can use all kind of transformers to as a expected values for fields.  The only difference is for file fields. You cannot check uploaded files just like that, however we prepared a special type of handler\nthat allow to check for some information related to a specific file.  Let's assume that after upload we display an information with a file name of a uploaded file.  You can use a special handler that requires to set a element with a postfix  Uploaded . This will check if a value of that element is the same as you expected.  For example you can write a step like this:  the  myform  form is filled with:\n  | myFileUploaded | file.txt |  Keep in mind that the element name must end with  Uploaded  for example:  this.myFileUploaded = $('p.some-file')", 
            "title": "the \":formName\" form is filled with:"
        }, 
        {
            "location": "/steps/#the-error-messages-should-be-displayed", 
            "text": "Allows you to specify the error messages that should be displayed for a specific elements.  This step requires an array of format:  the error messages should be displayed:\n  | element   | errorMessage     |\n  | myElement | my error message |  Keep in mind that first row of array must be  | element | errorMessage | .  You can use dictionaries in this step as follows:  the error messages should be displayed:\n  | element   | errorMessage                   |\n  | myElement | d:dictionaryName:dictionaryKey |", 
            "title": "the error messages should be displayed:"
        }, 
        {
            "location": "/steps/#elements", 
            "text": "", 
            "title": "Elements"
        }, 
        {
            "location": "/steps/#i-wait-for-expectedconditionname-of-the-elementname-element", 
            "text": "Waits till element  :elementName  from  this.currentPage  meets criteria specified by  :expectedConditionName .  You can use any of the Protractor's expected condition:   visibilityOf  invisibilityOf   etc.  Read more in Protractor's API documentation.", 
            "title": "I wait for \":expectedConditionName\" of the \":elementName\" element"
        }, 
        {
            "location": "/steps/#i-wait-for-the-elementname-element-to-disappear", 
            "text": "Waits till element  :elementName  disappears.", 
            "title": "I wait for the \":elementName\" element to disappear"
        }, 
        {
            "location": "/steps/#i-scroll-to-the-elementname-element", 
            "text": "Scrolls to element  :elementName  of  this.currentPage . The element will be on bottom of the page.", 
            "title": "I scroll to the \":elementName\" element"
        }, 
        {
            "location": "/steps/#i-infinitely-scroll-to-the-elementname-element", 
            "text": "Allows to scroll till  :elementName  is visible. Useful for infinite scrolling functionality.", 
            "title": "I infinitely scroll to the \":elementName\" element"
        }, 
        {
            "location": "/steps/#i-press-the-keyname-key", 
            "text": "Performs a key press operation on  :keyName  key.", 
            "title": "I press the \":keyName\" key"
        }, 
        {
            "location": "/steps/#i-click-the-elementname-element", 
            "text": "Performs a click action on element  :elementName  from `this.currentPage'", 
            "title": "I click the \":elementName\" element"
        }, 
        {
            "location": "/steps/#i-click-the-elementname-element-if-it-is-visible", 
            "text": "Conditionally clicks on element  :elementName  of  this.currentPage  only if it is visible.", 
            "title": "I click the \":elementName\" element if it is visible"
        }, 
        {
            "location": "/steps/#i-click-the-elementname-on-the-first-item-of-containerelementname-element", 
            "text": "Allows to click on the first child element of  :containerElementName  specified in  this.currentName .  The child element must be specified by  :elementName  nd must be available in  this.currentPage", 
            "title": "I click the \":elementName\" on the first item of \":containerElementName\" element"
        }, 
        {
            "location": "/steps/#i-store-the-elementname-element-text-as-variablename-variable", 
            "text": "Stores the text from element  :elementName  of  this.currentPage  under the  :variableName  so you can use it later.", 
            "title": "I store the \":elementName\" element text as \":variableName\" variable"
        }, 
        {
            "location": "/steps/#i-update-the-elementname-element-text-as-variablename-variable", 
            "text": "Updates the variable  :variableName  value by value from element  :elementName  of  this.currentPage .", 
            "title": "I update the \":elementName\" element text as \":variableName\" variable"
        }, 
        {
            "location": "/steps/#i-store-the-elementname-element-text-matched-by-matchingregex-as-variablename-variable", 
            "text": "Stores the part of the element  :elementName  text, that matches the  :matchingRegex  under the  :variableName  for later use.", 
            "title": "I store the \":elementName\" element text matched by \":matchingRegex\" as \":variableName\" variable"
        }, 
        {
            "location": "/steps/#the-elementname-element-is-present", 
            "text": "Checks if element  :elementName  is available in HTML DOM", 
            "title": "the \":elementName\"\" element is present"
        }, 
        {
            "location": "/steps/#the-elementname-element-is-not-present", 
            "text": "Checks if element  :elementName  is not available in HTML DOM", 
            "title": "the \":elementName\"\" element is not present"
        }, 
        {
            "location": "/steps/#the-elementname-element-is-visible", 
            "text": "Checks if element  :elementName  is visible and clickable", 
            "title": "the \":elementName\"\" element is visible"
        }, 
        {
            "location": "/steps/#the-elementname-element-is-not-visible", 
            "text": "Checks if element  :elementName  is available in HTML DOM but is not visible and clickable", 
            "title": "the \":elementName\"\" element is not visible"
        }, 
        {
            "location": "/steps/#the-elementname-element-is-disabled", 
            "text": "Checks if element is disabled", 
            "title": "the \":elementName\" element is disabled"
        }, 
        {
            "location": "/steps/#i-store-table-tableelementname-rows-as-variablename-with-columns", 
            "text": "Allows to store a row specified columns from a table  :tableElementName  and save it under  :variableName  as an array of objects.  This step requires a table of columns locators, for example:  I store table  myTable  rows as  someVariable  with columns:\n  | firstName |\n  | lastName  |\n  | id        |  In order to make it work there must be not only element  myTable  in  this.currentPage , but also\nlocator  this.firstName = by.css('.firstName');  and so on.  The result of this step is an array of:  [\n  [\n    'firsRowFirstNameValue',\n    'firsRowLastNameValue'\n    'firsRowIdValue'\n  ]\n  ...\n]", 
            "title": "I store table \":tableElementName\" rows as \":variableName\" with columns:"
        }, 
        {
            "location": "/steps/#there-are-following-elements-in-table-elementname", 
            "text": "Allows to check if a child elements of  :elementName  have a specified content.  This steps allows you to specify an array of child elements locators that will be checked against expected values.  For example:  there are following elements in table  myTable :\n  | id  | firstName | lastName |\n  | t:1 | t:Adam    | t:Doe    |\n  | t:2 | t:John    | t:Doe    |  First row must specify columns locators. Starting from second row we must provider a matchers for each row that must be displayed.  This step checks exact match, so if the table has 5 rows, there must be a 5 rows in this table.  We can specify only a set of columns (for example if a table has 5 columns, we can specify only 1).", 
            "title": "there are following elements in table \":elementName\":"
        }, 
        {
            "location": "/steps/#there-are-numberexpression-following-elements-for-element-elementname", 
            "text": "Allows to check if a child elements of  :elementName  have a specified content. Element should be an array, for example:  table \n   tr \n     td 1 /td \n   /tr \n   tr \n     td 2 /td \n   /tr     /table   for this case the  :elementName  should be specified as  $$('table tr') .  Allows to check if a number of elements is the one that we expect.  numberExpression  is a supported expression from  chai.js  library:    equal N  where N is a number    at least N  where N is a number    above N  where N is a number    below N  where N is a number    within N M  where N and M are a numbers    and so on. You can check expressions on  chai.js  API dock for BDD.  This step requires an array of elements locators to be checked. For example:  there are  equal 5  following elements for element  myList :\n  | element    | value         |\n  | viewButton | f:isClickable |\n  | id         | r:idRegex     |  The first row must be  | element    | value | , after that we specify a list of element locators to be checked for each element of  :elementName  array.  The child elements must be a locators, for example  this.viewButton = by.css('button.viewButton'); .  You can use all kind of matchers here.", 
            "title": "there are \"numberExpression\" following elements for element \":elementName\":"
        }, 
        {
            "location": "/steps/#there-is-element-elementname-with-value-matcher", 
            "text": "Allows to check if  :elementName  has a value that matches the  :matcher .", 
            "title": "there is element \":elementName\" with value \":matcher\""
        }, 
        {
            "location": "/steps/#there-is-no-element-elementname-with-value-matchername", 
            "text": "Allows to check if there is no  :elementName  that matches the  :matcher .", 
            "title": "there is no element \":elementName\" with value \":matcherName\""
        }, 
        {
            "location": "/steps/#there-are-numberexpression-elementname-elements", 
            "text": "Allows to check if a number of  :elementName  elements is the same as we expect.  numberExpression  is a supported expression from  chai.js  library:    equal N  where N is a number    at least N  where N is a number    above N  where N is a number    below N  where N is a number    within N M  where N and M are a numbers    and so on. You can check expressions on  chai.js  API dock for BDD.  :elementName  should be specified as an array, for example:  table \n   tr \n     td 1 /td \n   /tr \n   tr \n     td 2 /td \n   /tr     /table   for this case the  :elementName  should be specified as  $$('table tr') .", 
            "title": "there are \"numberExpression\" \":elementName\" elements"
        }, 
        {
            "location": "/steps/#every-elementname-element-should-have-the-same-value-for-element-columnelementname", 
            "text": "Allows to check if every row defined by  :elementName  has the same value for a column  :columnElementName .  :elementName  must be an array of elements  :columnElementName  must be an locator, for example:  table \n   tr \n     td 1 /td \n   /tr \n   tr \n     td 1 /td \n   /tr     /table   for this case the  :elementName  should be specified as  $$('table tr')  and we can specify column locator this.myColumn = by.css('td'); . This allows us to write:  every \"myElement\" element should have the same value for element \"myColumn\"", 
            "title": "every \":elementName\" element should have the same value for element \":columnElementName\""
        }, 
        {
            "location": "/steps/#every-elementname-element-should-have-the-same-value-for-element-columnelementname-attribute-attributename", 
            "text": "The same as  every \":elementName\" element should have the same value for element \":columnElementName\" , but check if all cells have the same value for an\nattribute specified by  :atrributeName .", 
            "title": "every \":elementName\" element should have the same value for element \":columnElementName\" attribute \":attributeName\""
        }, 
        {
            "location": "/steps/#columnelementname-value-on-the-elementname-list-is-sorted-in-ascendingdescending-order", 
            "text": "Checks if the values for column  :columnElementName  of each row specified by  :elementName  is sorted in either ascending or descending order.  :columnElementName  must be a locator used to get a column on each row of an array  :elementName . For example:  table \n   tr \n     td 1 /td \n   /tr \n   tr \n     td 2 /td \n   /tr     /table   The  :elementName  should be specified as  this.myElement = $$('table tr')  The  :columnElementName  should be an locator  this.myColumn = by.css(td); .  Now we can use this step to check the order of elements.", 
            "title": "\":columnElementName\" value on the \":elementName\" list is sorted in \"ascending|descending\" order"
        }, 
        {
            "location": "/steps/#emails", 
            "text": "", 
            "title": "Emails"
        }, 
        {
            "location": "/steps/#the-email-has-been-sent-and-contains", 
            "text": "Checks if there is an email on the configured mailing service.  This steps requires an array of filters to be applied to mailbox in order to find an email you're looking for.  You can do this like this:  the email has been sent and contains:\n| html_body | t:some value | | |  The number of columns is always 4, but depending form a filter you have to use all of them or only some.  We do support filtering by any property returned in MailTrap Api response format. Go check  Extending Kakunin  for more information.  There are 2 custom filters:  the email has been sent and contains:\n| currentUser | | | |  This one checks if the user saved in  this.currentUser  variable is a recipient of an email. This is done by comparing  email  property of  this.currentUser  object to the one returned by email.  the email has been sent and contains:\n| file | t:fileName | r:fileExtension | sizeInBytes |  This one is looking for an attachment with a name matching  t:fileName , extension matching  r:fileExtension ,  sizeInBytes  as a minimum bytes size.  You can use the same filter multiple times:  the email has been sent and contains:\n| file | t:fileName      | r:fileExtension | sizeInBytes |\n| file | t:otherfileName | r:fileExtension | sizeInBytes |  This will look for an email with 2 attachments.", 
            "title": "the email has been sent and contains:"
        }, 
        {
            "location": "/steps/#files", 
            "text": "", 
            "title": "Files"
        }, 
        {
            "location": "/steps/#the-file-filename-should-be-downloaded", 
            "text": "Checks if a file with name  :fileName  was downloaded.  This step does not support matchers or regular expressions, so the name must be exact match. However you can use\nvariable store here.  Let's assume there is a variable  myFile  with a value  super-file  in variable store.  You can write  the file \"v:myFile.zip\" should be downloaded  to check if a file  super-file.zip  was downloaded.", 
            "title": "the file \":fileName\" should be downloaded"
        }, 
        {
            "location": "/steps/#the-file-filename-contains-table-data-stored-under-variablename-variable", 
            "text": "This step allows you to compare an xls/xlsx file  :fileName  with an existing data stored under  :variableName  variable.  The data under  :variableName  must be an array of objects representing each row of file.", 
            "title": "the file \":fileName\" contains table data stored under \":variableName\" variable"
        }, 
        {
            "location": "/steps/#generators", 
            "text": "", 
            "title": "Generators"
        }, 
        {
            "location": "/steps/#i-generate-random-generatorname-as-variablename", 
            "text": "Allows to generate a random value using the generator specified by  :generatorName .  The generator must be defined inside the any of the  generators  directories specified in  kakunin.conf.js  file  default: generators .  If the generator exists, then the value will be saved under the  :variableName  and can be accessed by:    steps using variable store    by calling  variableStore.getVariableValue(:variableName)    by using variable store transformer on supported steps  v:variableName", 
            "title": "I generate random \":generatorName\" as \":variableName\""
        }, 
        {
            "location": "/steps/#i-generate-random-generatorname-generatorparamter-as-variablename", 
            "text": "The same as  I generate random \":generatorName\" as \":variableName\"  but allows to pass additional parameter to generator.", 
            "title": "I generate random \":generatorName\" \":generatorParamter\" as \":variableName\""
        }, 
        {
            "location": "/steps/#debug", 
            "text": "", 
            "title": "Debug"
        }, 
        {
            "location": "/steps/#i-pause", 
            "text": "Pauses tests execution and allows to continue manually by pressing combination of  ctrl+c  inside terminal.", 
            "title": "I pause"
        }, 
        {
            "location": "/steps/#i-wait-for-seconds-seconds", 
            "text": "Waits with execution of next step for an amount provided by parameter  :seconds .", 
            "title": "I wait for \":seconds\" seconds"
        }, 
        {
            "location": "/matchers/", 
            "text": "Matchers allows you to check if a element content matches your expectation.\n\n\nFor example you can check if a value has a specified pattern or if a button is clickable.\n\n\nUsing matcher is very straightforward, for example: \nf:isClickable\n.\n\n\nMatchers can be used in most of the steps related to checking content (with exception of checking form values).\n\n\nKakunin comes with a set of built in matchers:\n\n\nVisibility matcher\n\n\nf:isVisible\n - checks if element is visible (must be in viewport and cannot be hidden behind any other element)\n\n\nInvisibility matcher\n\n\nf:isNotVisible\n - checks if element is not visible\n\n\nPresent matcher\n\n\nf:isPresent\n - checks if element is in html code (does not have to be visible)\n\n\nClickable matcher\n\n\nf:isClickable\n - checks if element is clickable\n\n\nNot clickable matcher\n\n\nf:isNotClickable\n - checks if element is not clickable\n\n\nAttribute matcher\n\n\nattribute:attributeName:regexName\n - allows to check if element has attribute with a name specified by \nattributeName\n and it has to \nhave a format passing \nregexName\n\n\nFor example, if there is an element:\n\n\np custom-attribute=\"123123\"\nsome value\n/p\n\n\nyou can check if attribute is an number by running: \nattribute:custom-attribute:number\n\n\nRegex matcher\n\n\nr:regexName\n - allows you to run a \nregexName\n against a text value of element\n\n\nRegexes have to be specified inside \nregex\n directory or be a kakunin built ones:\n\n\nnotEmpty\n - there must be a value\n\nnumber\n - must be a number\n\n\nYou can add your own matchers. In order to do so please read \nExtending Kakunin\n section.\n\n\nText matcher\n\n\nt:text you are looking for\n - allows you to check if an element contains a expected text", 
            "title": "Matchers"
        }, 
        {
            "location": "/matchers/#visibility-matcher", 
            "text": "f:isVisible  - checks if element is visible (must be in viewport and cannot be hidden behind any other element)", 
            "title": "Visibility matcher"
        }, 
        {
            "location": "/matchers/#invisibility-matcher", 
            "text": "f:isNotVisible  - checks if element is not visible", 
            "title": "Invisibility matcher"
        }, 
        {
            "location": "/matchers/#present-matcher", 
            "text": "f:isPresent  - checks if element is in html code (does not have to be visible)", 
            "title": "Present matcher"
        }, 
        {
            "location": "/matchers/#clickable-matcher", 
            "text": "f:isClickable  - checks if element is clickable", 
            "title": "Clickable matcher"
        }, 
        {
            "location": "/matchers/#not-clickable-matcher", 
            "text": "f:isNotClickable  - checks if element is not clickable", 
            "title": "Not clickable matcher"
        }, 
        {
            "location": "/matchers/#attribute-matcher", 
            "text": "attribute:attributeName:regexName  - allows to check if element has attribute with a name specified by  attributeName  and it has to \nhave a format passing  regexName  For example, if there is an element:  p custom-attribute=\"123123\" some value /p  you can check if attribute is an number by running:  attribute:custom-attribute:number", 
            "title": "Attribute matcher"
        }, 
        {
            "location": "/matchers/#regex-matcher", 
            "text": "r:regexName  - allows you to run a  regexName  against a text value of element  Regexes have to be specified inside  regex  directory or be a kakunin built ones:  notEmpty  - there must be a value number  - must be a number  You can add your own matchers. In order to do so please read  Extending Kakunin  section.", 
            "title": "Regex matcher"
        }, 
        {
            "location": "/matchers/#text-matcher", 
            "text": "t:text you are looking for  - allows you to check if an element contains a expected text", 
            "title": "Text matcher"
        }, 
        {
            "location": "/transformers/", 
            "text": "Transformers allow you to transform values passed to form steps.\n\n\nFor example a select requires to pass a value \n/options/1b30f17e-e445-4d28-a30c-dedad95829ab\n. This one is quite unreadable, but with the help of transformers you are\nable to write it like this: \nd:options:someOptionName\n.\n\n\nIn real-life example it will look similar to:\n\n\nI fill the \nmyForm\n form with:\n  | inputElement    | d:someDictionary:someKey            |\n  | textareaElement | g:someGenerator                     |\n  | radioElement    | v:someVariableName                  |\n  | checkboxElement | standard value                      |\n\n\n\n\nThere are 3 types of built-in transformers:\n\n\nDictionaries\n\n\nDictionaries allows you to transform a value A to value B using a simple key-\nvalue transformation.\n\n\nYou can run a dictionary transformer by providing dictionary prefix \nd:\n, specifying the dictionary name and key that should be used as a value provider. For example:\n\n\nd:myDictionaryName:myDictionaryKey\n\n\nthis example assumes that there is a dictionary that supports name \nmyDictionaryName\n and it has \nmyDictionarKey\n key.\n\n\nYou can read about dictionaries in \nExtending Kakunin\n section.\n\n\nGenerators\n\n\nGenerators allows you to generate a value by using a specified generator.\n\n\nThis can be done by: \ng:generatorName\n.\n\n\nIf a generator supports parameters then you can specify them by:\n\n\ng:generatorName:param1:param2:...:paramN\n\n\nYou can read more about generators in \nExtending Kakunin\n section.\n\n\nVariable store\n\n\nVariable store allows you to fill the form with a value that was saved in previous steps of current running scenario.\n\n\nThis can be done by:\n\n\nv:variableName\n\n\nYou can read more about variable store in \nExtending Kakunin\n section", 
            "title": "Transformers"
        }, 
        {
            "location": "/transformers/#dictionaries", 
            "text": "Dictionaries allows you to transform a value A to value B using a simple key- value transformation.  You can run a dictionary transformer by providing dictionary prefix  d: , specifying the dictionary name and key that should be used as a value provider. For example:  d:myDictionaryName:myDictionaryKey  this example assumes that there is a dictionary that supports name  myDictionaryName  and it has  myDictionarKey  key.  You can read about dictionaries in  Extending Kakunin  section.", 
            "title": "Dictionaries"
        }, 
        {
            "location": "/transformers/#generators", 
            "text": "Generators allows you to generate a value by using a specified generator.  This can be done by:  g:generatorName .  If a generator supports parameters then you can specify them by:  g:generatorName:param1:param2:...:paramN  You can read more about generators in  Extending Kakunin  section.", 
            "title": "Generators"
        }, 
        {
            "location": "/transformers/#variable-store", 
            "text": "Variable store allows you to fill the form with a value that was saved in previous steps of current running scenario.  This can be done by:  v:variableName  You can read more about variable store in  Extending Kakunin  section", 
            "title": "Variable store"
        }, 
        {
            "location": "/extending/", 
            "text": "Kakunin allows you to easily add a custom code in order to extend it's functionality.\n\n\nInternal services\n\n\nRegex builder\n\n\nRegex builder is a special builder for creating \nRegExp\n objects based on regexp name. Internally it has access to not only to all built-in \nregular expression files, but also custom ones specified by user. \n\n\nconst { regexBuilder } = require('kakunin');\n\nconst myRegex = regexBuilder.buildRegex('r:number');\n\n//myRegex will contain RegExp object that matches regular expression under the name \nnumber\n in regexes file.\n\n\n\n\nVariable store\n\n\nVariable store allows you to store and read some values to be used during given scenario.\n\n\nconst { variableStore } = require('kakunin');\n\nvariableStore.storeVariable('some-name', 'some-value');\n\nconst myValue = variableStore.getVariableValue('some-name'); //contains 'some-value'\n\n\n\n\nUser provider\n\n\nKakunin comes with functionality that allows you to easily load credentials for a given account type - \nUserProvider\n.\n\n\nIn \nkakunin.conf.js\n you can find a section \naccounts\n.\n\n\nThe structure it has is very simple: \n\n\naccounts\n: {\n    \nsomeAccount\n: {\n        \naccounts\n: [\n            {\n                \nemail\n: \n,\n                \npassword\n: \n\n            }\n        ]\n    }\n}\n\n\n\n\nsomeAccount\n - the name of accounts group\n\n\naccounts\n - an array of account credentials (in order to be able to check if a \ncurrentUser\n got an email, this has to have an \nemail\n key, otherwise account can have any kind of\nproperties)\n\n\nUse provider is accessible inside any kind of a step by calling \nthis.userProvider\n. It comes with a single method:\n\n\nthis.userProvider.getUser(groupName)\n - returns an account credentials for a given user group.\n\n\nIt is a good practice to save a current user in \nthis.currentUser\n variable for a email checking service.\n\n\nAdding custom code\n\n\nCustom step\n\n\nIn order to add a custom step, you have to create inside of a directory specified as \nstep_definitions\n in kakunin configuration file \ndefault: /step_definitions\n.\n\n\nWe're using \ncucumber-js 2.X\n so in order to add custom step you have to use \ndefineSupportCode\n method like this:\n\n\n  const { defineSupportCode } = require('kakunin');\n\n  defineSupportCode(({ When }) =\n {\n    When(/^I use kakunin$/, function() {\n      expect(true).to.equal(true);\n    });\n  });\n\n\n\n\nPage objects\n\n\nKakunin comes with some built-in page objects, that should be used as a base for your page objects.\n\n\nIn order to create a custom one, create a file inside the \npages\n directory and extend either \nBasePage\n or \nFormPage\n from kakunin package.\n\n\nconst { BasePage } = require('kakunin');\n\nclass MyPageObject extends BasePage {\n  constructor() {\n    this.myElement = element(by.css('.some-elemnt'));\n  }\n}\n\nmodule.exports = new MyPageObject();\n\n\n\n\nThe only difference between \nBasePage\n and \nFormPage\n is a support for form submission.\n\n\nconst { FormPage } = require('kakunin');\n\nclass MyFormTypePage extends FormPage {\n  constructor() {\n    this.myElement = element(by.css('.some-elemnt'));\n  }\n}\n\nmodule.exports = new MyFormTypePage();\n\n\n\n\nMatchers\n\n\nMatchers are used to compare if given value is matching our expectation. For example if a value in table is a number.\n\n\nYou can add your own matcher as below:\n\n\nconst { matchers } = require('kakunin');\n\nclass MyMatcher {\n  isSatisfiedBy(prefix, name) {\n    return prefix === 'm:' \n name === 'pending';\n  }\n\n  match(protractorElement, matcherName) {\n    return protractorElement.getText().then((value) =\n value === 'pending'); \n  }\n}\n\nmatchers.addMatcher(new MyMatcher());\n\n\n\n\nDictionaries\n\n\nDictionaries allows you to present complicated values in much more readable way. For example if an element must be\nin a form of IRI \n/some-resource/123-123-123-23\n and you wish to use \npending-resource\n as it's alias.\n\n\nYou can add your own dictionary:\n\n\nconst { dictionaries } = require('kakunin');\n\nclass MyDictionary{\n  constructor() {\n    this.values = {\n      '/some-resource/123-123-123-23':'pending-resource'\n    };\n\n    this.name === 'resources';\n  }\n\n  isSatisfiedBy(name) {\n    return this.name === name;\n  }\n\n  getMappedValue(key) {\n    return this.values[key];\n  }\n}\n\ndictionaries.addDictionary(new MyDictionary());\n\n\n\n\nGenerators\n\n\nGenerators allows you to create random values\n\n\nYou can add your own generator:\n\n\nconst { generators } = require('kakunin');\n\nclass MyGeneerator{\n  isSatisfiedBy(name) {\n    return this.name === 'my-generator';\n  }\n\n  generate(params) {\n    return Promise.resolve('some-random-value');\n  }\n}\n\ngenerators.addGenerator(new MyGeneerator());\n\n\n\n\nComparators\n\n\nComparators allows you to check if a set of values has an expected order\n\n\nYou can add your own comparators:\n\n\nconst { comparators } = require('kakunin');\n\nclass MyComparator {\n  isSatisfiedBy(values) {\n    for(let i=0; i\nvalues.length; i++) {\n      if (values[i] !== 'foo' \n values[i] !== 'bar') {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  compare(values, order) {\n    for (let i = 1; i \n values.length; i++) {\n      const previousValue = values[i - 1];\n      const currentValue = values[i];\n\n      if (previousValue === currentValue) {\n        return Promise.reject('Wrong order');\n      }\n    }\n\n    return Promise.resolve('Foo bar!');\n  }\n};\n\ncomparators.addComparator(new MyComparator());\n\n\n\n\nForm handlers\n\n\nForm handlers allows you to fill the form inputs and check value of filled fields\n\n\nYou can add your own handlers:\n\n\nconst { handlers } = require('kakunin');\n\nconst MyHandler {\n  constructor() {\n    this.registerFieldType = false;\n    this.fieldType = 'default';\n  }\n\n  isSatisfiedBy(element, elementName) {\n    return Promise.resolve(elementName === 'someElementName');\n  }\n\n  handleFill(page, elementName, desiredValue) {\n    return page[elementName].isDisplayed()\n      .then(function () {\n        return page[elementName].clear().then(function () {\n          return page[elementName].sendKeys(desiredValue);\n        });\n      }\n    );\n  }\n\n  handleCheck(page, elementName, desiredValue) {\n    return page[elementName].isDisplayed()\n      .then(function () {\n        return page[elementName].getAttribute('value').then(function (value) {\n          if (value === desiredValue) {\n            return Promise.resolve();\n          }\n\n          return Promise.reject(`Expected ${desiredValue} got ${value} for text input element ${elementName}`);\n        });\n      }\n    );\n  }\n};\n\nhandlers.addHandler(new MyHandler());\n\n\n\n\nTransformers\n\n\nTransformers can be used in steps \nWhen I fill the \"form\" form with:\n and \nAnd the \"joinOurStoreForm\" form is filled with:\n.\n\n\nExisting transformers:\n- generators (prefix: \ng:\n)\n- dictionaries (prefix: \nd:\n)\n- variableStore (prefix: \nv:\n)\nTransformers can be used in mentioned steps by using specific 'prefix', parameters are sent after \n:\n sign.\nExample:\n\ng:generatorName:param:param\n\n\nYou can add your own handlers:\n\n\nconst { transformers } = require('kakunin');\n\nclass MyTransformer {\n\n  isSatisfiedBy(prefix) {\n    return 'yourPrefix:' === prefix;\n  }\n\n  transform(value) {\n    //code\n  }\n}\ntransformers.addTransformer(new MyTransformer());\n\n\n\n\nEmail checking service\n\n\nYou can easily check emails with Kakunin. By default we give you MailTrap client implementation, but you can easily add your own client. \n\n\nconst { emailService } = require('kakunin');\n\nclass MyEmailService {\n  //you have access to full kakunin config\n  isSatisfiedBy(config) {\n    return config.email.type === 'my-custom-email-service';\n  }\n\n  //method used to clear emails before tests\n  clearInbox() {\n    ...\n  }\n\n  //method used to get emails - this method should return emails in format described below\n  getEmails() {\n    ...\n  }\n\n  //method used to retrive atachments for given email - should return attachments in format described below\n  getAttachments(email) {\n    ...\n  }\n\n  //method used to mark given email as read\n  markAsRead(email) {\n    ...\n  }\n}\n\nemailService.addAdapter(new MyEmailService());\n\n\n\n\nEmails should be returned as an array of objects with given schema:\n\n\n  [\n    {\n      \nsubject\n: \nSMTP e-mail test\n,\n      \nsent_at\n: \n2013-08-25T19:32:07.567+03:00\n,\n      \nfrom_email\n: \nme@railsware.com\n,\n      \nfrom_name\n: \nPrivate Person\n,\n      \nto_email\n: \ntest@railsware.com\n,\n      \nto_name\n: \nA Test User\n,\n      \nhtml_body\n: \n,\n      \ntext_body\n: \nThis is a test e-mail message.\\r\\n\n,\n      \nemail_size\n: 193,\n      \nis_read\n: true,\n      \ncreated_at\n: \n2013-08-25T19:32:07.576+03:00\n,\n      \nupdated_at\n: \n2013-08-25T19:32:09.232+03:00\n,\n      \nsent_at_timestamp\n: 1377448326\n    }\n  ]\n\n\n\n\nthis is MailTrap email format.\n\n\nAttachments should be returned as an array of objects with given schema:\n\n\n[\n  {\n    \nid\n: 1737,\n    \nmessage_id\n: 54508,\n    \nfilename\n: \nPhotos.png\n,\n    \nattachment_type\n: \nattachment\n,\n    \ncontent_type\n: \nimage/png\n,\n    \ncontent_id\n: \n,\n    \ntransfer_encoding\n: \nbase64\n,\n    \nattachment_size\n: 213855,\n    \ncreated_at\n: \n2013-08-16T00:39:34.677+03:00\n,\n    \nupdated_at\n: \n2013-08-16T00:39:34.677+03:00\n,\n    \nattachment_human_size\n: \n210 KB\n,\n    \ndownload_path\n: \n/api/v1/inboxes/3/messages/54508/attachments/1737/download\n\n  }\n]\n\n\n\n\nthis is MailTrap attachment format.", 
            "title": "Extending Kakunin"
        }, 
        {
            "location": "/extending/#internal-services", 
            "text": "", 
            "title": "Internal services"
        }, 
        {
            "location": "/extending/#regex-builder", 
            "text": "Regex builder is a special builder for creating  RegExp  objects based on regexp name. Internally it has access to not only to all built-in \nregular expression files, but also custom ones specified by user.   const { regexBuilder } = require('kakunin');\n\nconst myRegex = regexBuilder.buildRegex('r:number');\n\n//myRegex will contain RegExp object that matches regular expression under the name  number  in regexes file.", 
            "title": "Regex builder"
        }, 
        {
            "location": "/extending/#variable-store", 
            "text": "Variable store allows you to store and read some values to be used during given scenario.  const { variableStore } = require('kakunin');\n\nvariableStore.storeVariable('some-name', 'some-value');\n\nconst myValue = variableStore.getVariableValue('some-name'); //contains 'some-value'", 
            "title": "Variable store"
        }, 
        {
            "location": "/extending/#user-provider", 
            "text": "Kakunin comes with functionality that allows you to easily load credentials for a given account type -  UserProvider .  In  kakunin.conf.js  you can find a section  accounts .  The structure it has is very simple:   accounts : {\n     someAccount : {\n         accounts : [\n            {\n                 email :  ,\n                 password :  \n            }\n        ]\n    }\n}  someAccount  - the name of accounts group  accounts  - an array of account credentials (in order to be able to check if a  currentUser  got an email, this has to have an  email  key, otherwise account can have any kind of\nproperties)  Use provider is accessible inside any kind of a step by calling  this.userProvider . It comes with a single method:  this.userProvider.getUser(groupName)  - returns an account credentials for a given user group.  It is a good practice to save a current user in  this.currentUser  variable for a email checking service.", 
            "title": "User provider"
        }, 
        {
            "location": "/extending/#adding-custom-code", 
            "text": "", 
            "title": "Adding custom code"
        }, 
        {
            "location": "/extending/#custom-step", 
            "text": "In order to add a custom step, you have to create inside of a directory specified as  step_definitions  in kakunin configuration file  default: /step_definitions .  We're using  cucumber-js 2.X  so in order to add custom step you have to use  defineSupportCode  method like this:    const { defineSupportCode } = require('kakunin');\n\n  defineSupportCode(({ When }) =  {\n    When(/^I use kakunin$/, function() {\n      expect(true).to.equal(true);\n    });\n  });", 
            "title": "Custom step"
        }, 
        {
            "location": "/extending/#page-objects", 
            "text": "Kakunin comes with some built-in page objects, that should be used as a base for your page objects.  In order to create a custom one, create a file inside the  pages  directory and extend either  BasePage  or  FormPage  from kakunin package.  const { BasePage } = require('kakunin');\n\nclass MyPageObject extends BasePage {\n  constructor() {\n    this.myElement = element(by.css('.some-elemnt'));\n  }\n}\n\nmodule.exports = new MyPageObject();  The only difference between  BasePage  and  FormPage  is a support for form submission.  const { FormPage } = require('kakunin');\n\nclass MyFormTypePage extends FormPage {\n  constructor() {\n    this.myElement = element(by.css('.some-elemnt'));\n  }\n}\n\nmodule.exports = new MyFormTypePage();", 
            "title": "Page objects"
        }, 
        {
            "location": "/extending/#matchers", 
            "text": "Matchers are used to compare if given value is matching our expectation. For example if a value in table is a number.  You can add your own matcher as below:  const { matchers } = require('kakunin');\n\nclass MyMatcher {\n  isSatisfiedBy(prefix, name) {\n    return prefix === 'm:'   name === 'pending';\n  }\n\n  match(protractorElement, matcherName) {\n    return protractorElement.getText().then((value) =  value === 'pending'); \n  }\n}\n\nmatchers.addMatcher(new MyMatcher());", 
            "title": "Matchers"
        }, 
        {
            "location": "/extending/#dictionaries", 
            "text": "Dictionaries allows you to present complicated values in much more readable way. For example if an element must be\nin a form of IRI  /some-resource/123-123-123-23  and you wish to use  pending-resource  as it's alias.  You can add your own dictionary:  const { dictionaries } = require('kakunin');\n\nclass MyDictionary{\n  constructor() {\n    this.values = {\n      '/some-resource/123-123-123-23':'pending-resource'\n    };\n\n    this.name === 'resources';\n  }\n\n  isSatisfiedBy(name) {\n    return this.name === name;\n  }\n\n  getMappedValue(key) {\n    return this.values[key];\n  }\n}\n\ndictionaries.addDictionary(new MyDictionary());", 
            "title": "Dictionaries"
        }, 
        {
            "location": "/extending/#generators", 
            "text": "Generators allows you to create random values  You can add your own generator:  const { generators } = require('kakunin');\n\nclass MyGeneerator{\n  isSatisfiedBy(name) {\n    return this.name === 'my-generator';\n  }\n\n  generate(params) {\n    return Promise.resolve('some-random-value');\n  }\n}\n\ngenerators.addGenerator(new MyGeneerator());", 
            "title": "Generators"
        }, 
        {
            "location": "/extending/#comparators", 
            "text": "Comparators allows you to check if a set of values has an expected order  You can add your own comparators:  const { comparators } = require('kakunin');\n\nclass MyComparator {\n  isSatisfiedBy(values) {\n    for(let i=0; i values.length; i++) {\n      if (values[i] !== 'foo'   values[i] !== 'bar') {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  compare(values, order) {\n    for (let i = 1; i   values.length; i++) {\n      const previousValue = values[i - 1];\n      const currentValue = values[i];\n\n      if (previousValue === currentValue) {\n        return Promise.reject('Wrong order');\n      }\n    }\n\n    return Promise.resolve('Foo bar!');\n  }\n};\n\ncomparators.addComparator(new MyComparator());", 
            "title": "Comparators"
        }, 
        {
            "location": "/extending/#form-handlers", 
            "text": "Form handlers allows you to fill the form inputs and check value of filled fields  You can add your own handlers:  const { handlers } = require('kakunin');\n\nconst MyHandler {\n  constructor() {\n    this.registerFieldType = false;\n    this.fieldType = 'default';\n  }\n\n  isSatisfiedBy(element, elementName) {\n    return Promise.resolve(elementName === 'someElementName');\n  }\n\n  handleFill(page, elementName, desiredValue) {\n    return page[elementName].isDisplayed()\n      .then(function () {\n        return page[elementName].clear().then(function () {\n          return page[elementName].sendKeys(desiredValue);\n        });\n      }\n    );\n  }\n\n  handleCheck(page, elementName, desiredValue) {\n    return page[elementName].isDisplayed()\n      .then(function () {\n        return page[elementName].getAttribute('value').then(function (value) {\n          if (value === desiredValue) {\n            return Promise.resolve();\n          }\n\n          return Promise.reject(`Expected ${desiredValue} got ${value} for text input element ${elementName}`);\n        });\n      }\n    );\n  }\n};\n\nhandlers.addHandler(new MyHandler());", 
            "title": "Form handlers"
        }, 
        {
            "location": "/extending/#transformers", 
            "text": "Transformers can be used in steps  When I fill the \"form\" form with:  and  And the \"joinOurStoreForm\" form is filled with: .  Existing transformers:\n- generators (prefix:  g: )\n- dictionaries (prefix:  d: )\n- variableStore (prefix:  v: )\nTransformers can be used in mentioned steps by using specific 'prefix', parameters are sent after  :  sign.\nExample: g:generatorName:param:param  You can add your own handlers:  const { transformers } = require('kakunin');\n\nclass MyTransformer {\n\n  isSatisfiedBy(prefix) {\n    return 'yourPrefix:' === prefix;\n  }\n\n  transform(value) {\n    //code\n  }\n}\ntransformers.addTransformer(new MyTransformer());", 
            "title": "Transformers"
        }, 
        {
            "location": "/extending/#email-checking-service", 
            "text": "You can easily check emails with Kakunin. By default we give you MailTrap client implementation, but you can easily add your own client.   const { emailService } = require('kakunin');\n\nclass MyEmailService {\n  //you have access to full kakunin config\n  isSatisfiedBy(config) {\n    return config.email.type === 'my-custom-email-service';\n  }\n\n  //method used to clear emails before tests\n  clearInbox() {\n    ...\n  }\n\n  //method used to get emails - this method should return emails in format described below\n  getEmails() {\n    ...\n  }\n\n  //method used to retrive atachments for given email - should return attachments in format described below\n  getAttachments(email) {\n    ...\n  }\n\n  //method used to mark given email as read\n  markAsRead(email) {\n    ...\n  }\n}\n\nemailService.addAdapter(new MyEmailService());  Emails should be returned as an array of objects with given schema:    [\n    {\n       subject :  SMTP e-mail test ,\n       sent_at :  2013-08-25T19:32:07.567+03:00 ,\n       from_email :  me@railsware.com ,\n       from_name :  Private Person ,\n       to_email :  test@railsware.com ,\n       to_name :  A Test User ,\n       html_body :  ,\n       text_body :  This is a test e-mail message.\\r\\n ,\n       email_size : 193,\n       is_read : true,\n       created_at :  2013-08-25T19:32:07.576+03:00 ,\n       updated_at :  2013-08-25T19:32:09.232+03:00 ,\n       sent_at_timestamp : 1377448326\n    }\n  ]  this is MailTrap email format.  Attachments should be returned as an array of objects with given schema:  [\n  {\n     id : 1737,\n     message_id : 54508,\n     filename :  Photos.png ,\n     attachment_type :  attachment ,\n     content_type :  image/png ,\n     content_id :  ,\n     transfer_encoding :  base64 ,\n     attachment_size : 213855,\n     created_at :  2013-08-16T00:39:34.677+03:00 ,\n     updated_at :  2013-08-16T00:39:34.677+03:00 ,\n     attachment_human_size :  210 KB ,\n     download_path :  /api/v1/inboxes/3/messages/54508/attachments/1737/download \n  }\n]  this is MailTrap attachment format.", 
            "title": "Email checking service"
        }, 
        {
            "location": "/changelog/", 
            "text": "v1.16.3\n\n\n\n\nchanged \nThere are \"equal 4\" following elements for element \"rows\":\n error message to be more descriptive\n\n\nadded express app to handle form submit tests\n\n\nadded tests form html default field types and tabular content validation\n\n\n\n\nv1.16.2\n\n\n\n\nadded new step \nI visit the \"pageName\" page with parameters:\n which replaces wildcards with a values given in the table\n\n\nfixed step \nI wait for \"condition\" of the \"element\" element\n, currently timeout is set properly to \nelementsVisibilityTimeout\n key which is placed in kakunin.config.js \n\n\nimproved step \nI wait for \"condition\" of the \"element\" element\n, currently singleElement and arrayElements can be checked\n\n\nchange step implementation: \nI click the \"keyName\" key\n to \nI press the \"keyName\" key\n\n\n\n\nv1.16.1\n\n\n\n\nadded changelog\n\n\nadded directory for mailing service adapters [\nemails\n] and connect it to modules loading system\n\n\nfixed a bug where exported mailing service and the one used internally where a different instances", 
            "title": "Changelog"
        }, 
        {
            "location": "/changelog/#v1163", 
            "text": "changed  There are \"equal 4\" following elements for element \"rows\":  error message to be more descriptive  added express app to handle form submit tests  added tests form html default field types and tabular content validation", 
            "title": "v1.16.3"
        }, 
        {
            "location": "/changelog/#v1162", 
            "text": "added new step  I visit the \"pageName\" page with parameters:  which replaces wildcards with a values given in the table  fixed step  I wait for \"condition\" of the \"element\" element , currently timeout is set properly to  elementsVisibilityTimeout  key which is placed in kakunin.config.js   improved step  I wait for \"condition\" of the \"element\" element , currently singleElement and arrayElements can be checked  change step implementation:  I click the \"keyName\" key  to  I press the \"keyName\" key", 
            "title": "v1.16.2"
        }, 
        {
            "location": "/changelog/#v1161", 
            "text": "added changelog  added directory for mailing service adapters [ emails ] and connect it to modules loading system  fixed a bug where exported mailing service and the one used internally where a different instances", 
            "title": "v1.16.1"
        }
    ]
}