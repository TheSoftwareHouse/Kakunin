{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"configuration/","text":"Kakunin config module . exports = { browserWidth : 1600 , browserHeight : 900 , timeout : 60 , maxEmailRepeats : 5 , intervalEmail : 5 , elementsVisibilityTimeout : 5 , waitForPageTimeout : 5 , downloadTimeout : 30 , reports : /reports , downloads : /downloads , data : /data , features : [ /features ], pages : [ /pages ], matchers : [ /matchers ], generators : [ /generators ], form_handlers : [ /form_handlers ], step_definitions : [ /step_definitions ], comparators : [ /comparators ], dictionaries : [ /dictionaries ], transformers : [ /transformers ], regexes : [ /regexes ], hooks : [ /hooks ], clearEmailInboxBeforeTests : false , clearCookiesAfterScenario : true , clearLocalStorageAfterScenario : true , email : null , headless : false , noGpu : false , type : otherWeb , baseUrl : http://localhost:8080 , accounts : { someAccount : { accounts : [ { email : , password : } ] } } } Configuration options browserWidth - width of browser window default: 1600 browserheight - height of browser window default: 900 timeout - global timeout for a single step execution in seconds default: 60 maxEmailRepeats - maximum email repeats to catch email used in the email step intervalEmail - interval for email checking step default: 5 in seconds elementsVisibilityTimeout - maximum wait timeout for element visibility default: 5 seconds waitForPageTimeout - maximum wait timeout for page visibility default: 5 seconds downloadTimeout - maximum wait timeout for file to be downloaded default: 30 seconds emails - array of paths to store emails related custom code reports - path to store reports downloads - path to store downloaded files data - path to store test related files (for example files to be downloaded) feature - array of paths to store features pages - array of paths to store page objects matchers - array of paths to store custom matchers generators - array of paths to store custom generators form_handlers - array of paths to store custom form handlers step_definitions - array of paths to store custom steps comparators - array of paths to store custom comparators dictionaries - array of paths to store custom dictionaries transformers - array of paths to store custom transformers regexes - array of paths to store custom regexes hooks - array of paths to store custom hooks clearEmailInboxBeforeTests - flag to active clearing email inbox before tests are executed default: false | true for apps with email checking functionality activated clearCookiesAfterScenario - flag to activate clearing cookies after every scenario default: true clearLocalStorageAfterScenario - flag to activate clearing local storage after every scenario default: true email - email configuration default: null for mailtrap email checking system: type : mailtrap , config : { apiKey : your-mailtrap-api-key , inboxId : your-mailtrap-inbox , url : https://mailtrap.io/api/v1 } for custom email checking system only type is required: type : custom-type headless - flag to activate chrome headless browser default: false noGpu - flag to activate cpu only mode default: false type - type of application otherWeb baseUrl - url of tested application accounts - object to store accounts information. This is bound to userProvider and allows to use advanced email checking options like recipient checking. someAccount : { accounts : [ { email : , password : } ] } Environment variables Kakunin uses a single .env file to load ENV variables. By default there is only one: FIXTURES_RELOAD_HOST - allows you to specify host for fixtures reloading. This allows you to use @reloadFixtures tag on scenarios that should restore database to starting state, before the test is running","title":"Configuration"},{"location":"configuration/#kakunin-config","text":"module . exports = { browserWidth : 1600 , browserHeight : 900 , timeout : 60 , maxEmailRepeats : 5 , intervalEmail : 5 , elementsVisibilityTimeout : 5 , waitForPageTimeout : 5 , downloadTimeout : 30 , reports : /reports , downloads : /downloads , data : /data , features : [ /features ], pages : [ /pages ], matchers : [ /matchers ], generators : [ /generators ], form_handlers : [ /form_handlers ], step_definitions : [ /step_definitions ], comparators : [ /comparators ], dictionaries : [ /dictionaries ], transformers : [ /transformers ], regexes : [ /regexes ], hooks : [ /hooks ], clearEmailInboxBeforeTests : false , clearCookiesAfterScenario : true , clearLocalStorageAfterScenario : true , email : null , headless : false , noGpu : false , type : otherWeb , baseUrl : http://localhost:8080 , accounts : { someAccount : { accounts : [ { email : , password : } ] } } }","title":"Kakunin config"},{"location":"configuration/#configuration-options","text":"browserWidth - width of browser window default: 1600 browserheight - height of browser window default: 900 timeout - global timeout for a single step execution in seconds default: 60 maxEmailRepeats - maximum email repeats to catch email used in the email step intervalEmail - interval for email checking step default: 5 in seconds elementsVisibilityTimeout - maximum wait timeout for element visibility default: 5 seconds waitForPageTimeout - maximum wait timeout for page visibility default: 5 seconds downloadTimeout - maximum wait timeout for file to be downloaded default: 30 seconds emails - array of paths to store emails related custom code reports - path to store reports downloads - path to store downloaded files data - path to store test related files (for example files to be downloaded) feature - array of paths to store features pages - array of paths to store page objects matchers - array of paths to store custom matchers generators - array of paths to store custom generators form_handlers - array of paths to store custom form handlers step_definitions - array of paths to store custom steps comparators - array of paths to store custom comparators dictionaries - array of paths to store custom dictionaries transformers - array of paths to store custom transformers regexes - array of paths to store custom regexes hooks - array of paths to store custom hooks clearEmailInboxBeforeTests - flag to active clearing email inbox before tests are executed default: false | true for apps with email checking functionality activated clearCookiesAfterScenario - flag to activate clearing cookies after every scenario default: true clearLocalStorageAfterScenario - flag to activate clearing local storage after every scenario default: true email - email configuration default: null for mailtrap email checking system: type : mailtrap , config : { apiKey : your-mailtrap-api-key , inboxId : your-mailtrap-inbox , url : https://mailtrap.io/api/v1 } for custom email checking system only type is required: type : custom-type headless - flag to activate chrome headless browser default: false noGpu - flag to activate cpu only mode default: false type - type of application otherWeb baseUrl - url of tested application accounts - object to store accounts information. This is bound to userProvider and allows to use advanced email checking options like recipient checking. someAccount : { accounts : [ { email : , password : } ] }","title":"Configuration options"},{"location":"configuration/#environment-variables","text":"Kakunin uses a single .env file to load ENV variables. By default there is only one: FIXTURES_RELOAD_HOST - allows you to specify host for fixtures reloading. This allows you to use @reloadFixtures tag on scenarios that should restore database to starting state, before the test is running","title":"Environment variables"},{"location":"cross-browser/","text":"Cross-browser To run tests with specified browser There is a possibility to run Kakunin in various browsers: Google Chrome (by default) npm run kakunin or npm run kakunin -- --chrome Firefox npm run kakunin -- --firefox Safari npm run kakunin -- --safari To run tests in different browsers at once There is a possibility to run more than one instance of WebDriver by giving an extra parameter to a command line: npm run kakunin --chrome --firefox Safari Run tests Open Safari's preferences Enable \"Show Develop menu in menu bar\" Open \"Develop\" tab Enable \"Allow Remote Automation\" Troubleshooting Safari version 12.0: - drag drop actions in Kakunin impossible (more details https://github.com/angular/protractor/issues/1526)","title":"Cross-browser"},{"location":"cross-browser/#cross-browser","text":"","title":"Cross-browser"},{"location":"cross-browser/#to-run-tests-with-specified-browser","text":"There is a possibility to run Kakunin in various browsers: Google Chrome (by default) npm run kakunin or npm run kakunin -- --chrome Firefox npm run kakunin -- --firefox Safari npm run kakunin -- --safari","title":"To run tests with specified browser"},{"location":"cross-browser/#to-run-tests-in-different-browsers-at-once","text":"There is a possibility to run more than one instance of WebDriver by giving an extra parameter to a command line: npm run kakunin --chrome --firefox","title":"To run tests in different browsers at once"},{"location":"cross-browser/#safari","text":"","title":"Safari"},{"location":"cross-browser/#run-tests","text":"Open Safari's preferences Enable \"Show Develop menu in menu bar\" Open \"Develop\" tab Enable \"Allow Remote Automation\"","title":"Run tests"},{"location":"cross-browser/#troubleshooting","text":"Safari version 12.0: - drag drop actions in Kakunin impossible (more details https://github.com/angular/protractor/issues/1526)","title":"Troubleshooting"},{"location":"extending/","text":"Kakunin allows you to easily add a custom code in order to extend it's functionality. Internal services Regex builder Regex builder is a special builder for creating RegExp objects based on regexp name. Internally it has access to not only to all built-in regular expression files, but also custom ones specified by user. const { regexBuilder } = require ( kakunin ); const myRegex = regexBuilder . buildRegex ( r:number ); //myRegex will contain RegExp object that matches regular expression under the name number in regexes file. Variable store Variable store allows you to store and read some values to be used during given scenario. const { variableStore } = require ( kakunin ); variableStore . storeVariable ( some-name , some-value ); const myValue = variableStore . getVariableValue ( some-name ); //contains some-value User provider Kakunin comes with functionality that allows you to easily load credentials for a given account type - UserProvider . In kakunin.conf.js you can find a section accounts . The structure it has is very simple: accounts : { someAccount : { accounts : [ { email : , password : } ] } } someAccount - the name of accounts group accounts - an array of account credentials (in order to be able to check if a currentUser got an email, this has to have an email key, otherwise account can have any kind of properties) Use provider is accessible inside any kind of a step by calling this.userProvider . It comes with a single method: this.userProvider.getUser(groupName) - returns an account credentials for a given user group. It is a good practice to save a current user in this.currentUser variable for a email checking service. Adding custom code Custom step In order to add a custom step, you have to create inside of a directory specified as step_definitions in kakunin configuration file default: /step_definitions . We're using cucumber-js 4.X so in order to add custom step you have to use defineSupportCode method like this: const { defineSupportCode } = require ( kakunin ); defineSupportCode (({ When }) = { When ( /^I use kakunin$/ , function () { expect ( true ). to . equal ( true ); }); }); Page objects Kakunin comes with some built-in page objects, that should be used as a base for your page objects. In order to create a custom one, create a file inside the pages directory and extend the BasePage from kakunin package. const { BasePage } = require ( kakunin ); class MyPageObject extends BasePage { constructor () { this . myElement = element ( by . css ( .some-elemnt )); } } module . exports = MyPageObject ; Matchers Matchers are used to compare if given value is matching our expectation. For example if a value in table is a number. You can add your own matcher as below: const { matchers } = require ( kakunin ); class MyMatcher { isSatisfiedBy ( prefix , name ) { return prefix === m: name === pending ; } match ( protractorElement , matcherName ) { return protractorElement . getText (). then (( value ) = { if ( value === pending ) { return true ; } return Promise . reject ( `Matcher MyMatcher could not match value on element ${ protractorElement . locator () } . Expected: pending , given: ${ value } ` ); }); } } matchers . addMatcher ( new MyMatcher ()); Dictionaries Dictionaries allows you to present complicated values in much more readable way. For example if an element must be in a form of IRI /some-resource/123-123-123-23 and you wish to use pending-resource as it's alias. You can add your own dictionary: const { dictionaries } = require ( kakunin ); const { BaseDictionary } = require ( kakunin ); class TestDictionary extends BaseDictionary { constructor () { super ( name-of-dictionary , { pending-resource : /some-resource/123-123-123-23 , test-value : some other value }); } } dictionaries . addDictionary ( new TestDictionary ()); Generators Generators allows you to create random values You can add your own generator: const { generators } = require ( kakunin ); class MyGeneerator { isSatisfiedBy ( name ) { return name === my-generator ; } generate ( params ) { return Promise . resolve ( some-random-value ); } } generators . addGenerator ( new MyGeneerator ()); Comparators Comparators allows you to check if a set of values has an expected order You can add your own comparators: const { comparators } = require ( kakunin ); class MyComparator { isSatisfiedBy ( values ) { for ( let i = 0 ; i values . length ; i ++ ) { if ( values [ i ] !== foo values [ i ] !== bar ) { return false ; } } return true ; } compare ( values , order ) { for ( let i = 1 ; i values . length ; i ++ ) { const previousValue = values [ i - 1 ]; const currentValue = values [ i ]; if ( previousValue === currentValue ) { return Promise . reject ( Wrong order ); } } return Promise . resolve ( Foo bar! ); } }; comparators . addComparator ( new MyComparator ()); Form handlers Form handlers allows you to fill the form inputs and check value of filled fields You can add your own handlers: const { handlers } = require ( kakunin ); const MyHandler { constructor () { this . registerFieldType = false ; this . fieldType = default ; } isSatisfiedBy ( element , elementName ) { return Promise . resolve ( elementName === someElementName ); } handleFill ( page , elementName , desiredValue ) { return page [ elementName ]. isDisplayed () . then ( function () { return page [ elementName ]. clear (). then ( function () { return page [ elementName ]. sendKeys ( desiredValue ); }); } ); } handleCheck ( page , elementName , desiredValue ) { return page [ elementName ]. isDisplayed () . then ( function () { return page [ elementName ]. getAttribute ( value ). then ( function ( value ) { if ( value === desiredValue ) { return Promise . resolve (); } return Promise . reject ( `Expected ${ desiredValue } got ${ value } for text input element ${ elementName } ` ); }); } ); } }; handlers . addHandler ( new MyHandler ()); Transformers Transformers can be used in steps When I fill the \"form\" form with: and And the \"joinOurStoreForm\" form is filled with: . Existing transformers: - generators (prefix: g: ) - dictionaries (prefix: d: ) - variableStore (prefix: v: ) Transformers can be used in mentioned steps by using specific 'prefix', parameters are sent after : sign. Example: g:generatorName:param:param You can add your own handlers: const { transformers } = require ( kakunin ); class MyTransformer { isSatisfiedBy ( prefix ) { return yourPrefix: === prefix ; } transform ( value ) { //code } } transformers . addTransformer ( new MyTransformer ()); Email checking service You can easily check emails with Kakunin. By default we give you MailTrap client implementation, but you can easily add your own client. const { emailService } = require ( kakunin ); class MyEmailService { //you have access to full kakunin config isSatisfiedBy ( config ) { return config . email . type === my-custom-email-service ; } //method used to clear emails before tests clearInbox () { ... } //method used to get emails - this method should return emails in format described below getEmails () { ... } //method used to retrive atachments for given email - should return attachments in format described below getAttachments ( email ) { ... } //method used to mark given email as read markAsRead ( email ) { ... } } emailService . addAdapter ( new MyEmailService ()); Emails should be returned as an array of objects with given schema: [ { subject : SMTP e-mail test , sent_at : 2013-08-25T19:32:07.567+03:00 , from_email : me@railsware.com , from_name : Private Person , to_email : test@railsware.com , to_name : A Test User , html_body : , text_body : This is a test e-mail message.\\r\\n , email_size : 193 , is_read : true , created_at : 2013-08-25T19:32:07.576+03:00 , updated_at : 2013-08-25T19:32:09.232+03:00 , sent_at_timestamp : 1377448326 } ] this is MailTrap email format. Attachments should be returned as an array of objects with given schema: [ { id : 1737 , message_id : 54508 , filename : Photos.png , attachment_type : attachment , content_type : image/png , content_id : , transfer_encoding : base64 , attachment_size : 213855 , created_at : 2013-08-16T00:39:34.677+03:00 , updated_at : 2013-08-16T00:39:34.677+03:00 , attachment_human_size : 210 KB , download_path : /api/v1/inboxes/3/messages/54508/attachments/1737/download } ] this is MailTrap attachment format.","title":"Extending Kakunin"},{"location":"extending/#internal-services","text":"","title":"Internal services"},{"location":"extending/#regex-builder","text":"Regex builder is a special builder for creating RegExp objects based on regexp name. Internally it has access to not only to all built-in regular expression files, but also custom ones specified by user. const { regexBuilder } = require ( kakunin ); const myRegex = regexBuilder . buildRegex ( r:number ); //myRegex will contain RegExp object that matches regular expression under the name number in regexes file.","title":"Regex builder"},{"location":"extending/#variable-store","text":"Variable store allows you to store and read some values to be used during given scenario. const { variableStore } = require ( kakunin ); variableStore . storeVariable ( some-name , some-value ); const myValue = variableStore . getVariableValue ( some-name ); //contains some-value","title":"Variable store"},{"location":"extending/#user-provider","text":"Kakunin comes with functionality that allows you to easily load credentials for a given account type - UserProvider . In kakunin.conf.js you can find a section accounts . The structure it has is very simple: accounts : { someAccount : { accounts : [ { email : , password : } ] } } someAccount - the name of accounts group accounts - an array of account credentials (in order to be able to check if a currentUser got an email, this has to have an email key, otherwise account can have any kind of properties) Use provider is accessible inside any kind of a step by calling this.userProvider . It comes with a single method: this.userProvider.getUser(groupName) - returns an account credentials for a given user group. It is a good practice to save a current user in this.currentUser variable for a email checking service.","title":"User provider"},{"location":"extending/#adding-custom-code","text":"","title":"Adding custom code"},{"location":"extending/#custom-step","text":"In order to add a custom step, you have to create inside of a directory specified as step_definitions in kakunin configuration file default: /step_definitions . We're using cucumber-js 4.X so in order to add custom step you have to use defineSupportCode method like this: const { defineSupportCode } = require ( kakunin ); defineSupportCode (({ When }) = { When ( /^I use kakunin$/ , function () { expect ( true ). to . equal ( true ); }); });","title":"Custom step"},{"location":"extending/#page-objects","text":"Kakunin comes with some built-in page objects, that should be used as a base for your page objects. In order to create a custom one, create a file inside the pages directory and extend the BasePage from kakunin package. const { BasePage } = require ( kakunin ); class MyPageObject extends BasePage { constructor () { this . myElement = element ( by . css ( .some-elemnt )); } } module . exports = MyPageObject ;","title":"Page objects"},{"location":"extending/#matchers","text":"Matchers are used to compare if given value is matching our expectation. For example if a value in table is a number. You can add your own matcher as below: const { matchers } = require ( kakunin ); class MyMatcher { isSatisfiedBy ( prefix , name ) { return prefix === m: name === pending ; } match ( protractorElement , matcherName ) { return protractorElement . getText (). then (( value ) = { if ( value === pending ) { return true ; } return Promise . reject ( `Matcher MyMatcher could not match value on element ${ protractorElement . locator () } . Expected: pending , given: ${ value } ` ); }); } } matchers . addMatcher ( new MyMatcher ());","title":"Matchers"},{"location":"extending/#dictionaries","text":"Dictionaries allows you to present complicated values in much more readable way. For example if an element must be in a form of IRI /some-resource/123-123-123-23 and you wish to use pending-resource as it's alias. You can add your own dictionary: const { dictionaries } = require ( kakunin ); const { BaseDictionary } = require ( kakunin ); class TestDictionary extends BaseDictionary { constructor () { super ( name-of-dictionary , { pending-resource : /some-resource/123-123-123-23 , test-value : some other value }); } } dictionaries . addDictionary ( new TestDictionary ());","title":"Dictionaries"},{"location":"extending/#generators","text":"Generators allows you to create random values You can add your own generator: const { generators } = require ( kakunin ); class MyGeneerator { isSatisfiedBy ( name ) { return name === my-generator ; } generate ( params ) { return Promise . resolve ( some-random-value ); } } generators . addGenerator ( new MyGeneerator ());","title":"Generators"},{"location":"extending/#comparators","text":"Comparators allows you to check if a set of values has an expected order You can add your own comparators: const { comparators } = require ( kakunin ); class MyComparator { isSatisfiedBy ( values ) { for ( let i = 0 ; i values . length ; i ++ ) { if ( values [ i ] !== foo values [ i ] !== bar ) { return false ; } } return true ; } compare ( values , order ) { for ( let i = 1 ; i values . length ; i ++ ) { const previousValue = values [ i - 1 ]; const currentValue = values [ i ]; if ( previousValue === currentValue ) { return Promise . reject ( Wrong order ); } } return Promise . resolve ( Foo bar! ); } }; comparators . addComparator ( new MyComparator ());","title":"Comparators"},{"location":"extending/#form-handlers","text":"Form handlers allows you to fill the form inputs and check value of filled fields You can add your own handlers: const { handlers } = require ( kakunin ); const MyHandler { constructor () { this . registerFieldType = false ; this . fieldType = default ; } isSatisfiedBy ( element , elementName ) { return Promise . resolve ( elementName === someElementName ); } handleFill ( page , elementName , desiredValue ) { return page [ elementName ]. isDisplayed () . then ( function () { return page [ elementName ]. clear (). then ( function () { return page [ elementName ]. sendKeys ( desiredValue ); }); } ); } handleCheck ( page , elementName , desiredValue ) { return page [ elementName ]. isDisplayed () . then ( function () { return page [ elementName ]. getAttribute ( value ). then ( function ( value ) { if ( value === desiredValue ) { return Promise . resolve (); } return Promise . reject ( `Expected ${ desiredValue } got ${ value } for text input element ${ elementName } ` ); }); } ); } }; handlers . addHandler ( new MyHandler ());","title":"Form handlers"},{"location":"extending/#transformers","text":"Transformers can be used in steps When I fill the \"form\" form with: and And the \"joinOurStoreForm\" form is filled with: . Existing transformers: - generators (prefix: g: ) - dictionaries (prefix: d: ) - variableStore (prefix: v: ) Transformers can be used in mentioned steps by using specific 'prefix', parameters are sent after : sign. Example: g:generatorName:param:param You can add your own handlers: const { transformers } = require ( kakunin ); class MyTransformer { isSatisfiedBy ( prefix ) { return yourPrefix: === prefix ; } transform ( value ) { //code } } transformers . addTransformer ( new MyTransformer ());","title":"Transformers"},{"location":"extending/#email-checking-service","text":"You can easily check emails with Kakunin. By default we give you MailTrap client implementation, but you can easily add your own client. const { emailService } = require ( kakunin ); class MyEmailService { //you have access to full kakunin config isSatisfiedBy ( config ) { return config . email . type === my-custom-email-service ; } //method used to clear emails before tests clearInbox () { ... } //method used to get emails - this method should return emails in format described below getEmails () { ... } //method used to retrive atachments for given email - should return attachments in format described below getAttachments ( email ) { ... } //method used to mark given email as read markAsRead ( email ) { ... } } emailService . addAdapter ( new MyEmailService ()); Emails should be returned as an array of objects with given schema: [ { subject : SMTP e-mail test , sent_at : 2013-08-25T19:32:07.567+03:00 , from_email : me@railsware.com , from_name : Private Person , to_email : test@railsware.com , to_name : A Test User , html_body : , text_body : This is a test e-mail message.\\r\\n , email_size : 193 , is_read : true , created_at : 2013-08-25T19:32:07.576+03:00 , updated_at : 2013-08-25T19:32:09.232+03:00 , sent_at_timestamp : 1377448326 } ] this is MailTrap email format. Attachments should be returned as an array of objects with given schema: [ { id : 1737 , message_id : 54508 , filename : Photos.png , attachment_type : attachment , content_type : image/png , content_id : , transfer_encoding : base64 , attachment_size : 213855 , created_at : 2013-08-16T00:39:34.677+03:00 , updated_at : 2013-08-16T00:39:34.677+03:00 , attachment_human_size : 210 KB , download_path : /api/v1/inboxes/3/messages/54508/attachments/1737/download } ] this is MailTrap attachment format.","title":"Email checking service"},{"location":"getting-started/","text":"About Kakunin Kakunin is a Protractor extension created by The Software House sp. z o.o. and Takamol Holding. It allows you to write e2e test scenarios with a help of Gherkin language and JavaScript for all kind of applications - Angular, React and others. Installation In order to install Kakunin you have to make sure that you have installed: node.js - v7.8.0 min JDK Chrome Create directory for your project mkdir my_project Go to project directory cd my_project Initialize JavaScript project npm init Install dependencies npm install cross-env protractor webdriver-manager kakunin --save Inside package.json file; add new script in scripts section: kakunin : cross-env NODE_ENV=prod kakunin Configuration Create kakunin project npm run kakunin init The above command will run Kakunin's init script. Answer what kind of app you're going to test ( default: AngularJS ) Enter URL where your tested app will be running ( default: http://localhost:3000 ) * Choose if you plan to use some emails checking service ( default: none ) Also, there is a possibility to answer these question by a command line. npm run kakunin init -- --baseUrl https://google.com --emailType none Available parameters: baseUrl , type , emailType , emailApiKey , emailInboxId . You will not be asked about question that you already answered by a command. After the init process, a project files should be automatically created in your directory. This is an example of a console output after the init process is completed: Created file at path /Users/example-user/projects/test/kakunin.conf.js Created directory at path /Users/ user /TSHProjects/test/reports Created directory at path /Users/ user /TSHProjects/test/reports/report Created directory at path /Users/ user /TSHProjects/test/reports/report/features Created directory at path /Users/ user /TSHProjects/test/reports/performance Created directory at path /Users/ user /TSHProjects/test/downloads Created directory at path /Users/example-user/projects/test/data Created directory at path /Users/example-user/projects/test/features Created directory at path /Users/example-user/projects/test/pages Created directory at path /Users/example-user/projects/test/matchers Created directory at path /Users/example-user/projects/test/generators Created directory at path /Users/example-user/projects/test/form_handlers Created directory at path /Users/example-user/projects/test/step_definitions Created directory at path /Users/example-user/projects/test/comparators Created directory at path /Users/example-user/projects/test/dictionaries Created directory at path /Users/example-user/projects/test/regexes Created directory at path /Users/example-user/projects/test/hooks Created directory at path /Users/example-user/projects/test/transformers Created directory at path /Users/example-user/projects/test/emails Created file at path /Users/example-user/projects/test/downloads/.gitkeep Created file at path /Users/example-user/projects/test/reports/report/.gitkeep Created file at path /Users/example-user/projects/test/reports/report/features/.gitkeep Created file at path /Users/example-user/projects/test/reports/performance/.gitkeep Created file at path /Users/example-user/projects/test/features/example.feature Created file at path /Users/example-user/projects/test/pages/page.js Created file at path /Users/example-user/projects/test/matchers/matcher.js Created file at path /Users/example-user/projects/test/generators/generator.js Created file at path /Users/example-user/projects/test/step_definitions/steps.js Created file at path /Users/example-user/projects/test/regexes/regex.js Created file at path /Users/example-user/projects/test/hooks/hook.js And you're set! Now you can run the tests using Kakunin: npm run kakunin Commands npm run kakunin init [-- --advanced] - Create a new project by answering few simple questions (you can pass additional parameter to enter advanced mode where you can configure all Kakunin options by yourself) npm run kakunin - Run test scenarios npm run kakunin -- --tags @someTag - Run only scenarios tagged by @someTag npm run kakunin -- --tags \"@someTag and @otherTag\" - Run only scenarios tagged by @someTag and @otherTag at the same time npm run kakunin -- --tags \"@someTag or @otherTag\" - Run only scenarios tagged by @someTag or @otherTag npm run kakunin -- --tags \"not @someTag\" - Run only scenarios not tagged by @someTag Troubleshooting Tips In order to make cucumber steps autosuggestion work properly in JetBrains tools, make sure your project is ECMAScript 6 compatible and you have cucumberjs plugin installed. Due to non-resolved issue in Jetbrains editors ( see here ) we'll have to do one more step: Go to step_definitions directory cd step_definitions Paste this code into terminal and restart your IDE: For Linux/MacOs: ln -s ../node_modules/kakunin/dist/step_definitions/elements.js kakunin-elements.js ln -s ../node_modules/kakunin/dist/step_definitions/debug.js kakunin-debug.js ln -s ../node_modules/kakunin/dist/step_definitions/file.js kakunin-file.js ln -s ../node_modules/kakunin/dist/step_definitions/form.js kakunin-form.js ln -s ../node_modules/kakunin/dist/step_definitions/email.js kakunin-email.js ln -s ../node_modules/kakunin/dist/step_definitions/generators.js kakunin-generators.js ln -s ../node_modules/kakunin/dist/step_definitions/navigation.js kakunin-navigation.js For Windows 8+: (you have to do this as administrator) mklink kakunin-elements.js .. \\n ode_modules \\k akunin \\d ist \\s tep_definitions \\e lements.js mklink kakunin-debug.js ..\\node_modules\\kakunin\\dist\\step_definitions\\debug.js mklink kakunin-file.js .. \\n ode_modules \\k akunin \\d ist \\s tep_definitions \\f ile.js mklink kakunin-form.js ..\\node_modules\\kakunin\\dist\\step_definitions\\form.js mklink kakunin-email.js .. \\n ode_modules \\k akunin \\d ist \\s tep_definitions \\e mail.js mklink kakunin-generators.js ..\\node_modules\\kakunin\\dist\\step_definitions\\generators.js mklink kakunin-navigation.js .. \\n ode_modules \\k akunin \\d ist \\s tep_definitions \\n avigation.js Keep in mind that mklink is not available in older Windows distributions. This will create symlinks inside step_definitions directory and make cucumberjs plugin recognize kakunin built-in steps.","title":"Getting started"},{"location":"getting-started/#about-kakunin","text":"Kakunin is a Protractor extension created by The Software House sp. z o.o. and Takamol Holding. It allows you to write e2e test scenarios with a help of Gherkin language and JavaScript for all kind of applications - Angular, React and others.","title":"About Kakunin"},{"location":"getting-started/#installation","text":"In order to install Kakunin you have to make sure that you have installed: node.js - v7.8.0 min JDK Chrome Create directory for your project mkdir my_project Go to project directory cd my_project Initialize JavaScript project npm init Install dependencies npm install cross-env protractor webdriver-manager kakunin --save Inside package.json file; add new script in scripts section: kakunin : cross-env NODE_ENV=prod kakunin","title":"Installation"},{"location":"getting-started/#configuration","text":"Create kakunin project npm run kakunin init The above command will run Kakunin's init script. Answer what kind of app you're going to test ( default: AngularJS ) Enter URL where your tested app will be running ( default: http://localhost:3000 ) * Choose if you plan to use some emails checking service ( default: none ) Also, there is a possibility to answer these question by a command line. npm run kakunin init -- --baseUrl https://google.com --emailType none Available parameters: baseUrl , type , emailType , emailApiKey , emailInboxId . You will not be asked about question that you already answered by a command. After the init process, a project files should be automatically created in your directory. This is an example of a console output after the init process is completed: Created file at path /Users/example-user/projects/test/kakunin.conf.js Created directory at path /Users/ user /TSHProjects/test/reports Created directory at path /Users/ user /TSHProjects/test/reports/report Created directory at path /Users/ user /TSHProjects/test/reports/report/features Created directory at path /Users/ user /TSHProjects/test/reports/performance Created directory at path /Users/ user /TSHProjects/test/downloads Created directory at path /Users/example-user/projects/test/data Created directory at path /Users/example-user/projects/test/features Created directory at path /Users/example-user/projects/test/pages Created directory at path /Users/example-user/projects/test/matchers Created directory at path /Users/example-user/projects/test/generators Created directory at path /Users/example-user/projects/test/form_handlers Created directory at path /Users/example-user/projects/test/step_definitions Created directory at path /Users/example-user/projects/test/comparators Created directory at path /Users/example-user/projects/test/dictionaries Created directory at path /Users/example-user/projects/test/regexes Created directory at path /Users/example-user/projects/test/hooks Created directory at path /Users/example-user/projects/test/transformers Created directory at path /Users/example-user/projects/test/emails Created file at path /Users/example-user/projects/test/downloads/.gitkeep Created file at path /Users/example-user/projects/test/reports/report/.gitkeep Created file at path /Users/example-user/projects/test/reports/report/features/.gitkeep Created file at path /Users/example-user/projects/test/reports/performance/.gitkeep Created file at path /Users/example-user/projects/test/features/example.feature Created file at path /Users/example-user/projects/test/pages/page.js Created file at path /Users/example-user/projects/test/matchers/matcher.js Created file at path /Users/example-user/projects/test/generators/generator.js Created file at path /Users/example-user/projects/test/step_definitions/steps.js Created file at path /Users/example-user/projects/test/regexes/regex.js Created file at path /Users/example-user/projects/test/hooks/hook.js And you're set! Now you can run the tests using Kakunin: npm run kakunin","title":"Configuration"},{"location":"getting-started/#commands","text":"npm run kakunin init [-- --advanced] - Create a new project by answering few simple questions (you can pass additional parameter to enter advanced mode where you can configure all Kakunin options by yourself) npm run kakunin - Run test scenarios npm run kakunin -- --tags @someTag - Run only scenarios tagged by @someTag npm run kakunin -- --tags \"@someTag and @otherTag\" - Run only scenarios tagged by @someTag and @otherTag at the same time npm run kakunin -- --tags \"@someTag or @otherTag\" - Run only scenarios tagged by @someTag or @otherTag npm run kakunin -- --tags \"not @someTag\" - Run only scenarios not tagged by @someTag","title":"Commands"},{"location":"getting-started/#troubleshooting-tips","text":"In order to make cucumber steps autosuggestion work properly in JetBrains tools, make sure your project is ECMAScript 6 compatible and you have cucumberjs plugin installed. Due to non-resolved issue in Jetbrains editors ( see here ) we'll have to do one more step: Go to step_definitions directory cd step_definitions Paste this code into terminal and restart your IDE: For Linux/MacOs: ln -s ../node_modules/kakunin/dist/step_definitions/elements.js kakunin-elements.js ln -s ../node_modules/kakunin/dist/step_definitions/debug.js kakunin-debug.js ln -s ../node_modules/kakunin/dist/step_definitions/file.js kakunin-file.js ln -s ../node_modules/kakunin/dist/step_definitions/form.js kakunin-form.js ln -s ../node_modules/kakunin/dist/step_definitions/email.js kakunin-email.js ln -s ../node_modules/kakunin/dist/step_definitions/generators.js kakunin-generators.js ln -s ../node_modules/kakunin/dist/step_definitions/navigation.js kakunin-navigation.js For Windows 8+: (you have to do this as administrator) mklink kakunin-elements.js .. \\n ode_modules \\k akunin \\d ist \\s tep_definitions \\e lements.js mklink kakunin-debug.js ..\\node_modules\\kakunin\\dist\\step_definitions\\debug.js mklink kakunin-file.js .. \\n ode_modules \\k akunin \\d ist \\s tep_definitions \\f ile.js mklink kakunin-form.js ..\\node_modules\\kakunin\\dist\\step_definitions\\form.js mklink kakunin-email.js .. \\n ode_modules \\k akunin \\d ist \\s tep_definitions \\e mail.js mklink kakunin-generators.js ..\\node_modules\\kakunin\\dist\\step_definitions\\generators.js mklink kakunin-navigation.js .. \\n ode_modules \\k akunin \\d ist \\s tep_definitions \\n avigation.js Keep in mind that mklink is not available in older Windows distributions. This will create symlinks inside step_definitions directory and make cucumberjs plugin recognize kakunin built-in steps.","title":"Troubleshooting &amp; Tips"},{"location":"how-it-works/","text":"Kakunin is built with no-js experience in mind. Because of that you're able to test even complicated apps just by knowing Kakunin (Gherkin) steps and a few good practices. Concepts Kakunin uses cucumber-js internally, because of that all tests (or rather scenarios) are using Gherkin as a \"programming\" language. A simple scenario could look like this: Feature: Scenario: Display user profile for logged user Given I am logged in as a user When the dashboard page is displayed And I click the profileButton element Then the myProfile page is displayed And the myName element is visible This is how most of Kakunin test scenarios look like. There are a few concepts to be explained. Page objects Page object is a code representation of a page displayed in browser. Kakunin has built-in BasePage page object, that you should extend. Page object contains information about page url, its elements, locators, but can also have some custom methods if necessary. A very simple example of Kakunin's Page Object could look like the following: const { BasePage } = require ( kakunin ); class DashboardPage extends BasePage { constructor () { super (); this . url = /dashboard ; } } module . exports = DashboardPage ; As you can see a basic Page Object must extend one of the Kakunin's Objects and needs to have url field defined ( this.url ). This code should be saved inside pages directory in a file with js extension. Note that a file name is very important, because we're going to use it as parameter for steps. For example, the following step: When the dashboard page is displayed expects that there is a file named dashboard.js inside the pages directory. Every step that we are using is somehow connected to an object called currentPage . This object value is set to a page object that we expect to be on. This is done by two kinds of steps: Then the \"dashboard\" page is displayed - this one checks if current url in browser is the same as the one inside Page Object and changes a value of the currentPage field to this page object When I visit the \"dashboard\" page - this one goes to the url specified in Page Object and attaches the Page Object to the currentPage field as above This concept is a very simple and allows you to easily debug the framework. You can be sure that each subsequent step that declared below the ones above will be executed in context of a page object specified in those methods. For example, having the following code: Feature: Scenario: Display user profile for logged user Given I am logged in as a user When the dashboard page is displayed And I click the profileButton element Then the myProfile page is displayed And the myName element is visible The step named And I click the \"profileButton\" element is executed in context of dashboard Page Object, thus we can assume that profileButton should be defined inside the pages/dashboard.js file. At the same time the step And the \"myName\" element is visible is executed in context of myProfile , so myName should be defined in pages/myProfile.js file. Elements and locators The second concept that you have to understand are elements and locators. Every element that you see on website can be represented as a element inside the page object. This allows us to use it as a parameter for a step, as we did in: And the \"myName\" element is visible . Defining elements is very simple. Let's say we have such page object: const { BasePage } = require ( kakunin ); class DashboardPage extends BasePage { constructor () { super (); this . url = /dashboard ; } } module .exports = DashboardPage ; Elements should be defined inside constructor method. Let's add element for myName : const { BasePage } = require ( kakunin ); class DashboardPage extends BasePage { constructor () { super (); this . url = /dashboard ; this . myName = element ( by . css ( .myName )); } } module .exports = DashboardPage ; As you see we added a single line this.myName = element(by.css('.myName')); . by.css('.myName') - is a locator, this is a standard protractor syntax, you can read more on protractors documentation By joining element method with a locator, we created element to be used by our steps. Compare URLs Compare URL examples: Page Object URL Current Browser URL Base URL - config file Results http://localhost:8080/incorrect-data http://localhost:8080/tabular-data https://example-url.com FALSE http://localhost:8080/incorrect-data/ http://localhost:8080/tabular-data https://example-url.com FALSE http://google/incorrect-data http://localhost:8080/tabular-data https://example-url.com FALSE http://google/tabular-data http://localhost:8080/tabular-data https://example-url.com FALSE http://google/incorrect-data/ http://localhost:8080/tabular-data https://example-url.com FALSE /incorrect-data http://website.com/tabular-data https://example-url.com FALSE /incorrect-data/ http://website.com/tabular-data http://incorrect.com FALSE http://localhost:8080/tabular-data http://localhost:8080/tabular-data https://example-url.com TRUE http://localhost:8080/tabular-data/ http://localhost:8080/tabular-data http://localhost:8080 TRUE /tabular-data http://localhost:8080/tabular-data http://localhost:8080 TRUE /tabular-data/ http://localhost:8080/tabular-data http://localhost:8080 TRUE /tabular-data http://localhost:8080/tabular-data https://google.pl FALSE /tabular-data/ http://localhost:8080/tabular-data https://google.pl FALSE / https://google.pl/new https://google.pl FALSE https://google.pl/new https://google.pl FALSE http://localhost:8080 http://localhost:8080 TRUE / https://google.pl https://google.com FALSE https://google.com/:example/:name https://google.com/example/janek https://example-url.com TRUE https://google.com/:name https://google.com/janek https://example-url.com TRUE https://google.com/account/:username/settings/display https://google.com/account/janek/settings/display https://example-url.com TRUE /account/settings/:userType https://incorrect-host/account/settings/admin https://google.com FALSE /account/settings/:userType/something https://incorrect-host/account/settings/admin https://example-url.com FALSE https://incorrect-host/account/settings/:userType/something https://incorrect-host/account/settings/admin https://example-url.com FALSE /account/settings/:userType https://google.com/account/settings/user https://google.com TRUE","title":"How it works"},{"location":"how-it-works/#concepts","text":"Kakunin uses cucumber-js internally, because of that all tests (or rather scenarios) are using Gherkin as a \"programming\" language. A simple scenario could look like this: Feature: Scenario: Display user profile for logged user Given I am logged in as a user When the dashboard page is displayed And I click the profileButton element Then the myProfile page is displayed And the myName element is visible This is how most of Kakunin test scenarios look like. There are a few concepts to be explained.","title":"Concepts"},{"location":"how-it-works/#page-objects","text":"Page object is a code representation of a page displayed in browser. Kakunin has built-in BasePage page object, that you should extend. Page object contains information about page url, its elements, locators, but can also have some custom methods if necessary. A very simple example of Kakunin's Page Object could look like the following: const { BasePage } = require ( kakunin ); class DashboardPage extends BasePage { constructor () { super (); this . url = /dashboard ; } } module . exports = DashboardPage ; As you can see a basic Page Object must extend one of the Kakunin's Objects and needs to have url field defined ( this.url ). This code should be saved inside pages directory in a file with js extension. Note that a file name is very important, because we're going to use it as parameter for steps. For example, the following step: When the dashboard page is displayed expects that there is a file named dashboard.js inside the pages directory. Every step that we are using is somehow connected to an object called currentPage . This object value is set to a page object that we expect to be on. This is done by two kinds of steps: Then the \"dashboard\" page is displayed - this one checks if current url in browser is the same as the one inside Page Object and changes a value of the currentPage field to this page object When I visit the \"dashboard\" page - this one goes to the url specified in Page Object and attaches the Page Object to the currentPage field as above This concept is a very simple and allows you to easily debug the framework. You can be sure that each subsequent step that declared below the ones above will be executed in context of a page object specified in those methods. For example, having the following code: Feature: Scenario: Display user profile for logged user Given I am logged in as a user When the dashboard page is displayed And I click the profileButton element Then the myProfile page is displayed And the myName element is visible The step named And I click the \"profileButton\" element is executed in context of dashboard Page Object, thus we can assume that profileButton should be defined inside the pages/dashboard.js file. At the same time the step And the \"myName\" element is visible is executed in context of myProfile , so myName should be defined in pages/myProfile.js file.","title":"Page objects"},{"location":"how-it-works/#elements-and-locators","text":"The second concept that you have to understand are elements and locators. Every element that you see on website can be represented as a element inside the page object. This allows us to use it as a parameter for a step, as we did in: And the \"myName\" element is visible . Defining elements is very simple. Let's say we have such page object: const { BasePage } = require ( kakunin ); class DashboardPage extends BasePage { constructor () { super (); this . url = /dashboard ; } } module .exports = DashboardPage ; Elements should be defined inside constructor method. Let's add element for myName : const { BasePage } = require ( kakunin ); class DashboardPage extends BasePage { constructor () { super (); this . url = /dashboard ; this . myName = element ( by . css ( .myName )); } } module .exports = DashboardPage ; As you see we added a single line this.myName = element(by.css('.myName')); . by.css('.myName') - is a locator, this is a standard protractor syntax, you can read more on protractors documentation By joining element method with a locator, we created element to be used by our steps.","title":"Elements and locators"},{"location":"how-it-works/#compare-urls","text":"Compare URL examples: Page Object URL Current Browser URL Base URL - config file Results http://localhost:8080/incorrect-data http://localhost:8080/tabular-data https://example-url.com FALSE http://localhost:8080/incorrect-data/ http://localhost:8080/tabular-data https://example-url.com FALSE http://google/incorrect-data http://localhost:8080/tabular-data https://example-url.com FALSE http://google/tabular-data http://localhost:8080/tabular-data https://example-url.com FALSE http://google/incorrect-data/ http://localhost:8080/tabular-data https://example-url.com FALSE /incorrect-data http://website.com/tabular-data https://example-url.com FALSE /incorrect-data/ http://website.com/tabular-data http://incorrect.com FALSE http://localhost:8080/tabular-data http://localhost:8080/tabular-data https://example-url.com TRUE http://localhost:8080/tabular-data/ http://localhost:8080/tabular-data http://localhost:8080 TRUE /tabular-data http://localhost:8080/tabular-data http://localhost:8080 TRUE /tabular-data/ http://localhost:8080/tabular-data http://localhost:8080 TRUE /tabular-data http://localhost:8080/tabular-data https://google.pl FALSE /tabular-data/ http://localhost:8080/tabular-data https://google.pl FALSE / https://google.pl/new https://google.pl FALSE https://google.pl/new https://google.pl FALSE http://localhost:8080 http://localhost:8080 TRUE / https://google.pl https://google.com FALSE https://google.com/:example/:name https://google.com/example/janek https://example-url.com TRUE https://google.com/:name https://google.com/janek https://example-url.com TRUE https://google.com/account/:username/settings/display https://google.com/account/janek/settings/display https://example-url.com TRUE /account/settings/:userType https://incorrect-host/account/settings/admin https://google.com FALSE /account/settings/:userType/something https://incorrect-host/account/settings/admin https://example-url.com FALSE https://incorrect-host/account/settings/:userType/something https://incorrect-host/account/settings/admin https://example-url.com FALSE /account/settings/:userType https://google.com/account/settings/user https://google.com TRUE","title":"Compare URLs"},{"location":"how-to-debug/","text":"How to debug Install globally ndb : npm install -g ndb Run Kakunin with ndb before command: ndb npm run kakunin A new instance of Chromium will be started within a window where you can add breakpoints. ndb is synced with the project - you can make changes there. Keep in mind that ndb requires Node =8.0.0. It works best with Node =10. More information can be found under the link","title":"How to debug"},{"location":"how-to-debug/#how-to-debug","text":"Install globally ndb : npm install -g ndb Run Kakunin with ndb before command: ndb npm run kakunin A new instance of Chromium will be started within a window where you can add breakpoints. ndb is synced with the project - you can make changes there. Keep in mind that ndb requires Node =8.0.0. It works best with Node =10. More information can be found under the link","title":"How to debug"},{"location":"matchers/","text":"Matchers allows you to check if a element content matches your expectation. For example you can check if a value has a specified pattern or if a button is clickable. Using matcher is very straightforward, for example: f:isClickable . Matchers can be used in most of the steps related to checking content (with exception of checking form values). Kakunin comes with a set of built in matchers: Visibility matcher f:isVisible - checks if element is visible (must be in viewport and cannot be hidden behind any other element) Invisibility matcher f:isNotVisible - checks if element is not visible Present matcher f:isPresent - checks if element is in html code (does not have to be visible) Clickable matcher f:isClickable - checks if element is clickable Not clickable matcher f:isNotClickable - checks if element is not clickable Attribute matcher attribute:attributeName:regexName - allows to check if element has attribute with a name specified by attributeName and it has to have a format passing regexName For example, if there is an element: p custom-attribute=\"123123\" some value /p you can check if attribute is an number by running: attribute:custom-attribute:number Regex matcher r:regexName - allows you to run a regexName against a text value of element Regexes have to be specified inside regex directory or be a kakunin built ones: notEmpty - there must be a value number - must be a number You can add your own matchers. In order to do so please read Extending Kakunin section. Text matcher t:text you are looking for - allows you to check if an element contains a expected text Current date matcher f:currentDate:{format} - allows you to generate current date, {format} is optional, by default DD-MM-YYYY","title":"Matchers"},{"location":"matchers/#visibility-matcher","text":"f:isVisible - checks if element is visible (must be in viewport and cannot be hidden behind any other element)","title":"Visibility matcher"},{"location":"matchers/#invisibility-matcher","text":"f:isNotVisible - checks if element is not visible","title":"Invisibility matcher"},{"location":"matchers/#present-matcher","text":"f:isPresent - checks if element is in html code (does not have to be visible)","title":"Present matcher"},{"location":"matchers/#clickable-matcher","text":"f:isClickable - checks if element is clickable","title":"Clickable matcher"},{"location":"matchers/#not-clickable-matcher","text":"f:isNotClickable - checks if element is not clickable","title":"Not clickable matcher"},{"location":"matchers/#attribute-matcher","text":"attribute:attributeName:regexName - allows to check if element has attribute with a name specified by attributeName and it has to have a format passing regexName For example, if there is an element: p custom-attribute=\"123123\" some value /p you can check if attribute is an number by running: attribute:custom-attribute:number","title":"Attribute matcher"},{"location":"matchers/#regex-matcher","text":"r:regexName - allows you to run a regexName against a text value of element Regexes have to be specified inside regex directory or be a kakunin built ones: notEmpty - there must be a value number - must be a number You can add your own matchers. In order to do so please read Extending Kakunin section.","title":"Regex matcher"},{"location":"matchers/#text-matcher","text":"t:text you are looking for - allows you to check if an element contains a expected text","title":"Text matcher"},{"location":"matchers/#current-date-matcher","text":"f:currentDate:{format} - allows you to generate current date, {format} is optional, by default DD-MM-YYYY","title":"Current date matcher"},{"location":"parallel-testing/","text":"Parallel testing There is a possibility to run tests in parallel. How to execute Use a command npm run kakunin -- --parallel number of instances where number of instances is a number. Example: - npm run kakunin -- --chrome --parallel 2 Keep in mind that the merged report is available in the reports/report/index.html file. text Specify pattern per each instance npm run kakunin -- --parallel number of instances --pattern regex to much feature --pattern regex to much feature Keep in mind that: the number given in parallel must be equal to passed patterns number of instances is a number of instances of the specified browser regex is a pattern that is used to specify the list of specs that will be executed in each of the instances Troubleshooting Running more than one instance in Firefox is not possible now (fix in-progress).","title":"Parallel testing"},{"location":"parallel-testing/#parallel-testing","text":"There is a possibility to run tests in parallel.","title":"Parallel testing"},{"location":"parallel-testing/#how-to-execute","text":"Use a command npm run kakunin -- --parallel number of instances where number of instances is a number. Example: - npm run kakunin -- --chrome --parallel 2 Keep in mind that the merged report is available in the reports/report/index.html file. text","title":"How to execute"},{"location":"parallel-testing/#specify-pattern-per-each-instance","text":"npm run kakunin -- --parallel number of instances --pattern regex to much feature --pattern regex to much feature Keep in mind that: the number given in parallel must be equal to passed patterns number of instances is a number of instances of the specified browser regex is a pattern that is used to specify the list of specs that will be executed in each of the instances","title":"Specify pattern per each instance"},{"location":"parallel-testing/#troubleshooting","text":"Running more than one instance in Firefox is not possible now (fix in-progress).","title":"Troubleshooting"},{"location":"performance-testing/","text":"Performance testing is possible thanks to browsermob-proxy . It saves all data from network tab (Google Chrome console) which is generated during the test. There is a possibility to compare TTFB value with a maximum given one. TTFB (Time to first byte) measures the duration from the client making an HTTP request to the first byte of a response being received by the client's browser. More details can be found in documentation - Built-in steps section. What needs to be done? Get started Download browsermob-proxy from https://github.com/lightbody/browsermob-proxy Navigate in terminal to the catalog Use following command to start the REST API ./browsermob-proxy -port 8887 Configuration Add browsermob-proxy configuration to kakunin.conf.js You can use one of the following methods to configure browsermob-proxy: npm run kakunin init -- --advanced and go through the process or add it manually to the config file: browserMob : { serverPort : 8887 , port : 8888 , host : localhost } Run tests performance steps must be used in the scenario where you are testing performance Scenario must have a tag @performance Run tests with special parameter: npm run kakunin -- --performance Results .har files are saved in catalog reports/performance/*.har","title":"Performance testing"},{"location":"performance-testing/#what-needs-to-be-done","text":"","title":"What needs to be done?"},{"location":"performance-testing/#get-started","text":"Download browsermob-proxy from https://github.com/lightbody/browsermob-proxy Navigate in terminal to the catalog Use following command to start the REST API ./browsermob-proxy -port 8887","title":"Get started"},{"location":"performance-testing/#configuration","text":"Add browsermob-proxy configuration to kakunin.conf.js You can use one of the following methods to configure browsermob-proxy: npm run kakunin init -- --advanced and go through the process or add it manually to the config file: browserMob : { serverPort : 8887 , port : 8888 , host : localhost }","title":"Configuration"},{"location":"performance-testing/#run-tests","text":"performance steps must be used in the scenario where you are testing performance Scenario must have a tag @performance Run tests with special parameter: npm run kakunin -- --performance","title":"Run tests"},{"location":"performance-testing/#results","text":".har files are saved in catalog reports/performance/*.har","title":"Results"},{"location":"quickstart/","text":"Quickstart As a quick demonstration of the framework let's test the React variant of TodoMVC project. Of course other testing other frameworks is possible, you can try it by yourself! Install packages In order to install Kakunin you have to make sure that you have installed: node.js - v7.8.0 min JDK Chrome Create directory for your project and enter it bash $mkdir my_project cd my_project Initialize JavaScript project bash npm init Install dependencies bash npm install cross-env protractor webdriver-manager kakunin --save Inside package.json file add new script in scripts section: json \"kakunin\": \"cross-env NODE_ENV=prod kakunin\" Configure Kakunin Run initialization command bash npm run kakunin init answer literally few questions: What is base url? [http://localhost:3000] : http://todomvc.com What kind of email service would you like to use? : none And you're set! Now let's write some test! Test the app Create a page object that will contain instructions on how to locate elements in the projects. Create a file pages/main.js : const { BasePage } = require ( kakunin ); class MainPage extends BasePage { constructor () { super (); // define the main url for the page this . url = /examples/react/#/ ; // whole form tag this . addTodoForm = $ ( .todoapp ); // input field this . todoInput = $ ( input.new-todo ); // list of currently added todos this . todos = $$ ( .todo-list .view ); this . todoLabel = by . css ( label ); // first todo item in a list this . firstTodoItem = this . todos . get ( 0 ); } } module . exports = MainPage ; Now that we have prepared the locators, we can start writing our test. Let's test adding new todo item. Create a file named: features/adding_todo.feature with the following contents: Feature: Scenario: Adding todo Given I visit the main page And I wait for visibilityOf of the addTodoForm element And the addTodoForm element is visible When I fill the addTodoForm form with: | todoInput | My new todo | And I press the enter key Then there are equal 1 todos elements And that's it! All you have to do now is to run the test and watch the magic happens ;) npm run kakunin The tests may run quite fast so you might not been able to see that it really works as expected. To check if the todo items has been really added to the list, let's use a simple hack - let's pause the running test right after the todo has been added. To do that, let's upgrade our Scenario. Update the file: Feature: Scenario: Adding todo Given I visit the main page And I wait for visibilityOf of the addTodoForm element And the addTodoForm element is visible When I fill the addTodoForm form with: | todoInput | My new todo | And I wait for 1 seconds And I press the enter key When I fill the addTodoForm form with: | todoInput | Another todo item! | And I wait for 1 seconds And I press the enter key Then there are equal 2 todos elements Then I wait for 5 seconds As you can see, we've added 1 new step that waits for a second before \"pressing\" the enter key. We've also added a second todo item with a short pause at the end of the test so you can see the changes. If you want to see what can we do more with the TodoMVC project, take a look at the example dir, where you'll find a complete set of test for the project.","title":"Quick start"},{"location":"quickstart/#quickstart","text":"As a quick demonstration of the framework let's test the React variant of TodoMVC project. Of course other testing other frameworks is possible, you can try it by yourself!","title":"Quickstart"},{"location":"quickstart/#install-packages","text":"In order to install Kakunin you have to make sure that you have installed: node.js - v7.8.0 min JDK Chrome Create directory for your project and enter it bash $mkdir my_project cd my_project Initialize JavaScript project bash npm init Install dependencies bash npm install cross-env protractor webdriver-manager kakunin --save Inside package.json file add new script in scripts section: json \"kakunin\": \"cross-env NODE_ENV=prod kakunin\"","title":"Install packages"},{"location":"quickstart/#configure-kakunin","text":"Run initialization command bash npm run kakunin init answer literally few questions: What is base url? [http://localhost:3000] : http://todomvc.com What kind of email service would you like to use? : none And you're set! Now let's write some test!","title":"Configure Kakunin"},{"location":"quickstart/#test-the-app","text":"Create a page object that will contain instructions on how to locate elements in the projects. Create a file pages/main.js : const { BasePage } = require ( kakunin ); class MainPage extends BasePage { constructor () { super (); // define the main url for the page this . url = /examples/react/#/ ; // whole form tag this . addTodoForm = $ ( .todoapp ); // input field this . todoInput = $ ( input.new-todo ); // list of currently added todos this . todos = $$ ( .todo-list .view ); this . todoLabel = by . css ( label ); // first todo item in a list this . firstTodoItem = this . todos . get ( 0 ); } } module . exports = MainPage ; Now that we have prepared the locators, we can start writing our test. Let's test adding new todo item. Create a file named: features/adding_todo.feature with the following contents: Feature: Scenario: Adding todo Given I visit the main page And I wait for visibilityOf of the addTodoForm element And the addTodoForm element is visible When I fill the addTodoForm form with: | todoInput | My new todo | And I press the enter key Then there are equal 1 todos elements And that's it! All you have to do now is to run the test and watch the magic happens ;) npm run kakunin The tests may run quite fast so you might not been able to see that it really works as expected. To check if the todo items has been really added to the list, let's use a simple hack - let's pause the running test right after the todo has been added. To do that, let's upgrade our Scenario. Update the file: Feature: Scenario: Adding todo Given I visit the main page And I wait for visibilityOf of the addTodoForm element And the addTodoForm element is visible When I fill the addTodoForm form with: | todoInput | My new todo | And I wait for 1 seconds And I press the enter key When I fill the addTodoForm form with: | todoInput | Another todo item! | And I wait for 1 seconds And I press the enter key Then there are equal 2 todos elements Then I wait for 5 seconds As you can see, we've added 1 new step that waits for a second before \"pressing\" the enter key. We've also added a second todo item with a short pause at the end of the test so you can see the changes. If you want to see what can we do more with the TodoMVC project, take a look at the example dir, where you'll find a complete set of test for the project.","title":"Test the app"},{"location":"steps/","text":"Navigation I visit the \":pageFileName\" page Visits the url of the page object with :pageFileName name. In order to make it work we create a page object file with a name of :pageFileName . For example in case of: I visit the \"myPage\" page there should be a file myPage.js inside the pages directory. If we have a page object with a name somePageObject.js defined inside pages directory then: Given I visit the \"somePageObject\" page will set this.currentPage variable to somePageObject page and we should end up on somePageObject url. I visit the \":pageFileName\" page with parameters: The same as I visit the \":pageFileName\" page except allows to pass url parameters. If url of myPage is defined as this.url = /orders/:orderId/products/:productId then we can use this step to visit this page by: I visit the myPage page with parameters: | orderId | 1 | | productId | 2 | this will result in visiting the /orders/1/product/2 page. the \":pageFileName\" page is displayed Checks if current browser url matches url of pageFileName page object. If the url matches expected pattern then this.currentPage variable is set to pageFileName page object. Forms I fill the \":formName\" form with: Allows to fill the form with the name :formName and values provided as an array of inputs and values. The element with name :formName must be defined inside the currentPage page object. Input and values should be provided as an array for example: I fill the myForm form with: | inputElement | value to be typed into field | | textareaElement | value to be typed into textarea | | radioElement | radio value to be selected | | checkboxElement | checkbox label value to be selected | By default we support all basic HTML field types (text inputs, checkboxes, radios, selects, files and textareas) In order to use the default handlers the elements you use as input must follow pattern: For inputs: this.element = $('input') - element should point at input you want to fill For textareas: this.element = $('textarea') - element should point at textarea you want to fill For file input: this.element = $('input') - element should point at input you want to fill and value should a filename of file from data directory For selects: this.element = $('select') - element should point at select and value should be an value of expected option For radios: this.element = $$('radio[name=\"name-of-radio\"]') - element should be an array of all radio input of given name and value should be an value of radio you wish to select For checkboxes: Checkbox should have a html like: label My checkbox input type = checkbox name = some-name / / label this.element = $$('checkbox[name=\"name-of-radio\"]') - element should be an array of all checkboxes of given name and value should be a text from label of checkbox you want to fill You can use all kind of transformers to as a values for fields. the \":formName\" form is filled with: The same as I fill the \":formName\" form with: but allows to check if a form is filled with a given set of values. You can use all kind of transformers to as a expected values for fields. The only difference is for file fields. You cannot check uploaded files just like that, however we prepared a special type of handler that allow to check for some information related to a specific file. Let's assume that after upload we display an information with a file name of a uploaded file. You can use a special handler that requires to set a element with a postfix Uploaded . This will check if a value of that element is the same as you expected. For example you can write a step like this: the myform form is filled with: | myFileUploaded | file.txt | Keep in mind that the element name must end with Uploaded for example: this.myFileUploaded = $('p.some-file') the error messages should be displayed: Allows you to specify the error messages that should be displayed for a specific elements. This step requires an array of format: the error messages should be displayed: | myElement | my error message | You can use dictionaries in this step as follows: the error messages should be displayed: | myElement | d:dictionaryName:dictionaryKey | Elements I infinitely scroll to the \":elementName\" element Allows to scroll through infinite scroll mechanism. The :elementName is a name of a selector for loading trigger. I wait for \":expectedConditionName\" of the \":elementName\" element Waits till element :elementName from this.currentPage meets criteria specified by :expectedConditionName . You can use any of the Protractor's expected condition: visibilityOf invisibilityOf etc. Read more in Protractor's API documentation. I wait for the \":elementName\" element to disappear Waits till element :elementName disappears. I scroll to the \":elementName\" element Scrolls to element :elementName of this.currentPage . The element will be on bottom of the page. I infinitely scroll to the \":elementName\" element Allows to scroll till :elementName is visible. Useful for infinite scrolling functionality. I press the \":keyName\" key Performs a key press operation on :keyName key. I click the \":elementName\" element Performs a click action on element :elementName from `this.currentPage' The child element must be specified by :elementName and must be available in this.currentPage . I store the \":elementName\" element text as \":variableName\" variable Stores the text from element :elementName of this.currentPage under the :variableName so you can use it later. I update the \":elementName\" element text as \":variableName\" variable Updates the variable :variableName value by value from element :elementName of this.currentPage . I store the \":elementName\" element text matched by \":matchingRegex\" as \":variableName\" variable Stores the part of the element :elementName text, that matches the :matchingRegex under the :variableName for later use. the \":elementName\"\" element is visible Checks if element :elementName is visible and clickable the \":elementName\"\" element is not visible Checks if element :elementName is available in HTML DOM but is not visible and clickable the \":elementName\" element is disabled Checks if element is disabled I store table \":tableRow\" rows as \":variableName\" with columns: Allows to store a row specified columns from a table :tableRow and save it under :variableName as an array of objects. This step requires a table of columns elements, for example: I store table someRow rows as someVariable with columns: | firstName | | lastName | | id | In order to make it work there must be not only array element this.someRow = $$('.rows') in this.currentPage , but also element this.firstName = $('.firstName'); and so on. The result of this step is an array of: [ [ firsRowFirstNameValue , firsRowLastNameValue firsRowIdValue ] ... ] there are following elements in table \":elementName\": Allows to check if a child elements of :elementName have a specified content. This steps allows you to specify an array of child elements that will be checked against expected values. For example: there are following elements in table myTable : | id | firstName | lastName | | t:1 | t:Adam | t:Doe | | t:2 | t:John | t:Doe | First row must specify columns elements. Starting from second row we must provide a matchers for each row that must be displayed. This step checks exact match, so if the table has 5 rows, there must be a 5 rows in this table. We can specify only a set of columns (for example if a table has 5 columns, we can specify only 1). there are \"numberExpression\" following elements for element \":elementName\": Allows to check if a child elements of :elementName have a specified content. Element should be an array, for example: table tr td 1 / td / tr tr td 2 / td / tr / table for this case the :elementName should be specified as $$('table tr') . Allows to check if a number of elements is the one that we expect. numberExpression is a supported expression from chai.js library: equal N where N is a number at least N where N is a number above N where N is a number below N where N is a number within N M where N and M are a numbers and so on. You can check expressions on chai.js API dock for BDD. This step requires an array of elements to be checked. For example: there are equal 5 following elements for element myList : | viewButton | f:isClickable | | id | r:idRegex | The child elements must be an elements, for example this.viewButton = $('button.viewButton'); . You can use all kind of matchers here. there is element \":elementName\" with value \":matcher\" Allows to check if :elementName has a value that matches the :matcher . there is no element \":elementName\" with value \":matcherName\" Allows to check if there is no :elementName that matches the :matcher . there are \"numberExpression\" \":elementName\" elements Allows to check if a number of :elementName elements is the same as we expect. numberExpression is a supported expression from chai.js library: equal N where N is a number at least N where N is a number above N where N is a number below N where N is a number within N M where N and M are a numbers and so on. You can check expressions on chai.js API dock for BDD. :elementName should be specified as an array, for example: table tr td 1 / td / tr tr td 2 / td / tr / table for this case the :elementName should be specified as $$('table tr') . every \":elementName\" element should have the same value for element \":columnElementName\" Allows to check if every row defined by :elementName has the same value for a column :columnElementName . :elementName must be an array of elements :columnElementName must be an element, for example: table tr td 1 / td / tr tr td 1 / td / tr / table for this case the :elementName should be specified as $$('table tr') and we can specify column element this.myColumn = $('td'); . This allows us to write: every \"myElement\" element should have the same value for element \"myColumn\" the element \":elementName\" should have an item with values: Allows to check if any of the child elements of :elementName have a specified content (one matching element is enough). Element should be an array, for example: table tr td 1 / td / tr tr td 2 / td / tr / table for this case the :elementName should be specified as $$('table tr') . This step requires an array of elements to be checked. For example: the element myList should have an item with values: | id | t:1 | The child elements must be an elements, for example this.id = $('td'); . You can use all kind of matchers here. the element \":elementName\" should not have an item with values: Allows to check if the child elements of :elementName have a different content than that given in the table. Element should be an array, for example: table tr td 1 / td / tr tr td 2 / td / tr / table for this case the :elementName should be specified as $$('table tr') . This step requires an array of elements to be checked. For example: the element myList should have an item with values: | id | t:does-not-exist | The child elements must be an elements, for example this.id = $('td'); . You can use all kind of matchers here. I drag \":elementDrag\" element and drop over \":elementDrop\" element Clicks on :elementDrag and moves it onto :elementDrop while left mouse button is pressed, and then release it. Note: This step is not working on HTML5! Emails the email has been sent and contains: Checks if there is an email on the configured mailing service. This steps requires an array of filters to be applied to mailbox in order to find an email you're looking for. You can do this like this: the email has been sent and contains: | html_body | t:some value | | | The number of columns is always 4, but depending form a filter you have to use all of them or only some. We do support filtering by any property returned in MailTrap Api response format. Go check Extending Kakunin for more information. There are 2 custom filters: the email has been sent and contains: | currentUser | | | | This one checks if the user saved in this.currentUser variable is a recipient of an email. This is done by comparing email property of this.currentUser object to the one returned by email. the email has been sent and contains: | file | t:fileName | r:fileExtension | sizeInBytes | This one is looking for an attachment with a name matching t:fileName , extension matching r:fileExtension , sizeInBytes as a minimum bytes size. You can use the same filter multiple times: the email has been sent and contains: | file | t:fileName | r:fileExtension | sizeInBytes | | file | t:otherfileName | r:fileExtension | sizeInBytes | This will look for an email with 2 attachments. Note : Read ` MIGRATION - 2.2 . 0 . MD ` if you re using MailTrap the email with the following data has not been sent: Checks if there is an email on the configured mailing service. This steps requires an array of filters to be applied to mailbox in order to find an email. Only currentUser , to_email , subject , html_body filters can be used in this step (attachments will be ignored). currentUser is a custom filter which checks if the user saved in this.currentUser variable is a recipient of an email. This is done by comparing email property of this.currentUser object to the one returned by email. You can do this like this: the email with the following data has not been sent: | to_email | t:example@yopmail.com | | html_body | t:some value | The number of columns is always 4, but depending form a filter you have to use all of them or only some. You can use the same filter multiple times: the email has been sent and contains: | html_body | t:some value | | html_body | t:some other value | Note : Read ` MIGRATION - 2.2 . 0 . MD ` if you re using MailTrap Files the file \":fileName\" should be downloaded Checks if a file with name :fileName was downloaded. This step does not support matchers or regular expressions, so the name must be exact match. However you can use variable store here. Let's assume there is a variable myFile with a value super-file in variable store. You can write the file \"v:myFile.zip\" should be downloaded to check if a file super-file.zip was downloaded. the file \":fileName\" contains table data stored under \":variableName\" variable This step allows you to compare an xls/xlsx file :fileName with an existing data stored under :variableName variable. The data under :variableName must be an array of objects representing each row of file. Generators I generate random \":generator:param:param\" as \":variableName\" Allows to generate a random value using the generator specified by :generator:param:param . The generator must be defined inside the any of the generators directories specified in kakunin.conf.js file default: generators . If the generator exists, then the value will be saved under the :variableName and can be accessed by: steps using variable store by calling variableStore.getVariableValue(:variableName) by using variable store transformer on supported steps v:variableName Debug I wait for \":seconds\" seconds Waits with execution of next step for an amount provided by parameter :seconds . I start performance monitor mode It starts performance monitor mode. Keep in mind that REST API must be started on the port which must configured in kakunin.conf.js - serverPort: 8887 . More details can be found in documentation file performance-testing.md . I save performance report file as \"fileName\" It saves .har file with a name fileName in reports/performance catalog. For example: exampleReport-1511470954552.har Data is generated during the test - network tab in Chrome Chrome console. Keep in mind: I start performance monitor mode must be used before this step browserMob.port must be configured in kakunin.conf.js browserMob.host must be configured in kakunin.conf.js More details can be found in documentation file performance-testing.md . the requests should take a maximum of \"maxTiming\" milliseconds It compares every TTFB timing value from previously saved .har report with a maxTiming value. Slow requests are listed in your terminal in red colour. Keep in mind that I start performance monitor mode and I save performance report file as \"fileName\" steps must be executed before this one!","title":"Built-in steps"},{"location":"steps/#navigation","text":"","title":"Navigation"},{"location":"steps/#i-visit-the-pagefilename-page","text":"Visits the url of the page object with :pageFileName name. In order to make it work we create a page object file with a name of :pageFileName . For example in case of: I visit the \"myPage\" page there should be a file myPage.js inside the pages directory. If we have a page object with a name somePageObject.js defined inside pages directory then: Given I visit the \"somePageObject\" page will set this.currentPage variable to somePageObject page and we should end up on somePageObject url.","title":"I visit the \":pageFileName\" page"},{"location":"steps/#i-visit-the-pagefilename-page-with-parameters","text":"The same as I visit the \":pageFileName\" page except allows to pass url parameters. If url of myPage is defined as this.url = /orders/:orderId/products/:productId then we can use this step to visit this page by: I visit the myPage page with parameters: | orderId | 1 | | productId | 2 | this will result in visiting the /orders/1/product/2 page.","title":"I visit the \":pageFileName\" page with parameters:"},{"location":"steps/#the-pagefilename-page-is-displayed","text":"Checks if current browser url matches url of pageFileName page object. If the url matches expected pattern then this.currentPage variable is set to pageFileName page object.","title":"the \":pageFileName\" page is displayed"},{"location":"steps/#forms","text":"","title":"Forms"},{"location":"steps/#i-fill-the-formname-form-with","text":"Allows to fill the form with the name :formName and values provided as an array of inputs and values. The element with name :formName must be defined inside the currentPage page object. Input and values should be provided as an array for example: I fill the myForm form with: | inputElement | value to be typed into field | | textareaElement | value to be typed into textarea | | radioElement | radio value to be selected | | checkboxElement | checkbox label value to be selected | By default we support all basic HTML field types (text inputs, checkboxes, radios, selects, files and textareas) In order to use the default handlers the elements you use as input must follow pattern: For inputs: this.element = $('input') - element should point at input you want to fill For textareas: this.element = $('textarea') - element should point at textarea you want to fill For file input: this.element = $('input') - element should point at input you want to fill and value should a filename of file from data directory For selects: this.element = $('select') - element should point at select and value should be an value of expected option For radios: this.element = $$('radio[name=\"name-of-radio\"]') - element should be an array of all radio input of given name and value should be an value of radio you wish to select For checkboxes: Checkbox should have a html like: label My checkbox input type = checkbox name = some-name / / label this.element = $$('checkbox[name=\"name-of-radio\"]') - element should be an array of all checkboxes of given name and value should be a text from label of checkbox you want to fill You can use all kind of transformers to as a values for fields.","title":"I fill the \":formName\" form with:"},{"location":"steps/#the-formname-form-is-filled-with","text":"The same as I fill the \":formName\" form with: but allows to check if a form is filled with a given set of values. You can use all kind of transformers to as a expected values for fields. The only difference is for file fields. You cannot check uploaded files just like that, however we prepared a special type of handler that allow to check for some information related to a specific file. Let's assume that after upload we display an information with a file name of a uploaded file. You can use a special handler that requires to set a element with a postfix Uploaded . This will check if a value of that element is the same as you expected. For example you can write a step like this: the myform form is filled with: | myFileUploaded | file.txt | Keep in mind that the element name must end with Uploaded for example: this.myFileUploaded = $('p.some-file')","title":"the \":formName\" form is filled with:"},{"location":"steps/#the-error-messages-should-be-displayed","text":"Allows you to specify the error messages that should be displayed for a specific elements. This step requires an array of format: the error messages should be displayed: | myElement | my error message | You can use dictionaries in this step as follows: the error messages should be displayed: | myElement | d:dictionaryName:dictionaryKey |","title":"the error messages should be displayed:"},{"location":"steps/#elements","text":"","title":"Elements"},{"location":"steps/#i-infinitely-scroll-to-the-elementname-element","text":"Allows to scroll through infinite scroll mechanism. The :elementName is a name of a selector for loading trigger.","title":"I infinitely scroll to the \":elementName\" element"},{"location":"steps/#i-wait-for-expectedconditionname-of-the-elementname-element","text":"Waits till element :elementName from this.currentPage meets criteria specified by :expectedConditionName . You can use any of the Protractor's expected condition: visibilityOf invisibilityOf etc. Read more in Protractor's API documentation.","title":"I wait for \":expectedConditionName\" of the \":elementName\" element"},{"location":"steps/#i-wait-for-the-elementname-element-to-disappear","text":"Waits till element :elementName disappears.","title":"I wait for the \":elementName\" element to disappear"},{"location":"steps/#i-scroll-to-the-elementname-element","text":"Scrolls to element :elementName of this.currentPage . The element will be on bottom of the page.","title":"I scroll to the \":elementName\" element"},{"location":"steps/#i-infinitely-scroll-to-the-elementname-element_1","text":"Allows to scroll till :elementName is visible. Useful for infinite scrolling functionality.","title":"I infinitely scroll to the \":elementName\" element"},{"location":"steps/#i-press-the-keyname-key","text":"Performs a key press operation on :keyName key.","title":"I press the \":keyName\" key"},{"location":"steps/#i-click-the-elementname-element","text":"Performs a click action on element :elementName from `this.currentPage' The child element must be specified by :elementName and must be available in this.currentPage .","title":"I click the \":elementName\" element"},{"location":"steps/#i-store-the-elementname-element-text-as-variablename-variable","text":"Stores the text from element :elementName of this.currentPage under the :variableName so you can use it later.","title":"I store the \":elementName\" element text as \":variableName\" variable"},{"location":"steps/#i-update-the-elementname-element-text-as-variablename-variable","text":"Updates the variable :variableName value by value from element :elementName of this.currentPage .","title":"I update the \":elementName\" element text as \":variableName\" variable"},{"location":"steps/#i-store-the-elementname-element-text-matched-by-matchingregex-as-variablename-variable","text":"Stores the part of the element :elementName text, that matches the :matchingRegex under the :variableName for later use.","title":"I store the \":elementName\" element text matched by \":matchingRegex\" as \":variableName\" variable"},{"location":"steps/#the-elementname-element-is-visible","text":"Checks if element :elementName is visible and clickable","title":"the \":elementName\"\" element is visible"},{"location":"steps/#the-elementname-element-is-not-visible","text":"Checks if element :elementName is available in HTML DOM but is not visible and clickable","title":"the \":elementName\"\" element is not visible"},{"location":"steps/#the-elementname-element-is-disabled","text":"Checks if element is disabled","title":"the \":elementName\" element is disabled"},{"location":"steps/#i-store-table-tablerow-rows-as-variablename-with-columns","text":"Allows to store a row specified columns from a table :tableRow and save it under :variableName as an array of objects. This step requires a table of columns elements, for example: I store table someRow rows as someVariable with columns: | firstName | | lastName | | id | In order to make it work there must be not only array element this.someRow = $$('.rows') in this.currentPage , but also element this.firstName = $('.firstName'); and so on. The result of this step is an array of: [ [ firsRowFirstNameValue , firsRowLastNameValue firsRowIdValue ] ... ]","title":"I store table \":tableRow\" rows as \":variableName\" with columns:"},{"location":"steps/#there-are-following-elements-in-table-elementname","text":"Allows to check if a child elements of :elementName have a specified content. This steps allows you to specify an array of child elements that will be checked against expected values. For example: there are following elements in table myTable : | id | firstName | lastName | | t:1 | t:Adam | t:Doe | | t:2 | t:John | t:Doe | First row must specify columns elements. Starting from second row we must provide a matchers for each row that must be displayed. This step checks exact match, so if the table has 5 rows, there must be a 5 rows in this table. We can specify only a set of columns (for example if a table has 5 columns, we can specify only 1).","title":"there are following elements in table \":elementName\":"},{"location":"steps/#there-are-numberexpression-following-elements-for-element-elementname","text":"Allows to check if a child elements of :elementName have a specified content. Element should be an array, for example: table tr td 1 / td / tr tr td 2 / td / tr / table for this case the :elementName should be specified as $$('table tr') . Allows to check if a number of elements is the one that we expect. numberExpression is a supported expression from chai.js library: equal N where N is a number at least N where N is a number above N where N is a number below N where N is a number within N M where N and M are a numbers and so on. You can check expressions on chai.js API dock for BDD. This step requires an array of elements to be checked. For example: there are equal 5 following elements for element myList : | viewButton | f:isClickable | | id | r:idRegex | The child elements must be an elements, for example this.viewButton = $('button.viewButton'); . You can use all kind of matchers here.","title":"there are \"numberExpression\" following elements for element \":elementName\":"},{"location":"steps/#there-is-element-elementname-with-value-matcher","text":"Allows to check if :elementName has a value that matches the :matcher .","title":"there is element \":elementName\" with value \":matcher\""},{"location":"steps/#there-is-no-element-elementname-with-value-matchername","text":"Allows to check if there is no :elementName that matches the :matcher .","title":"there is no element \":elementName\" with value \":matcherName\""},{"location":"steps/#there-are-numberexpression-elementname-elements","text":"Allows to check if a number of :elementName elements is the same as we expect. numberExpression is a supported expression from chai.js library: equal N where N is a number at least N where N is a number above N where N is a number below N where N is a number within N M where N and M are a numbers and so on. You can check expressions on chai.js API dock for BDD. :elementName should be specified as an array, for example: table tr td 1 / td / tr tr td 2 / td / tr / table for this case the :elementName should be specified as $$('table tr') .","title":"there are \"numberExpression\" \":elementName\" elements"},{"location":"steps/#every-elementname-element-should-have-the-same-value-for-element-columnelementname","text":"Allows to check if every row defined by :elementName has the same value for a column :columnElementName . :elementName must be an array of elements :columnElementName must be an element, for example: table tr td 1 / td / tr tr td 1 / td / tr / table for this case the :elementName should be specified as $$('table tr') and we can specify column element this.myColumn = $('td'); . This allows us to write: every \"myElement\" element should have the same value for element \"myColumn\"","title":"every \":elementName\" element should have the same value for element \":columnElementName\""},{"location":"steps/#the-element-elementname-should-have-an-item-with-values","text":"Allows to check if any of the child elements of :elementName have a specified content (one matching element is enough). Element should be an array, for example: table tr td 1 / td / tr tr td 2 / td / tr / table for this case the :elementName should be specified as $$('table tr') . This step requires an array of elements to be checked. For example: the element myList should have an item with values: | id | t:1 | The child elements must be an elements, for example this.id = $('td'); . You can use all kind of matchers here.","title":"the element \":elementName\" should have an item with values:"},{"location":"steps/#the-element-elementname-should-not-have-an-item-with-values","text":"Allows to check if the child elements of :elementName have a different content than that given in the table. Element should be an array, for example: table tr td 1 / td / tr tr td 2 / td / tr / table for this case the :elementName should be specified as $$('table tr') . This step requires an array of elements to be checked. For example: the element myList should have an item with values: | id | t:does-not-exist | The child elements must be an elements, for example this.id = $('td'); . You can use all kind of matchers here.","title":"the element \":elementName\" should not have an item with values:"},{"location":"steps/#i-drag-elementdrag-element-and-drop-over-elementdrop-element","text":"Clicks on :elementDrag and moves it onto :elementDrop while left mouse button is pressed, and then release it. Note: This step is not working on HTML5!","title":"I drag \":elementDrag\" element and drop over \":elementDrop\" element"},{"location":"steps/#emails","text":"","title":"Emails"},{"location":"steps/#the-email-has-been-sent-and-contains","text":"Checks if there is an email on the configured mailing service. This steps requires an array of filters to be applied to mailbox in order to find an email you're looking for. You can do this like this: the email has been sent and contains: | html_body | t:some value | | | The number of columns is always 4, but depending form a filter you have to use all of them or only some. We do support filtering by any property returned in MailTrap Api response format. Go check Extending Kakunin for more information. There are 2 custom filters: the email has been sent and contains: | currentUser | | | | This one checks if the user saved in this.currentUser variable is a recipient of an email. This is done by comparing email property of this.currentUser object to the one returned by email. the email has been sent and contains: | file | t:fileName | r:fileExtension | sizeInBytes | This one is looking for an attachment with a name matching t:fileName , extension matching r:fileExtension , sizeInBytes as a minimum bytes size. You can use the same filter multiple times: the email has been sent and contains: | file | t:fileName | r:fileExtension | sizeInBytes | | file | t:otherfileName | r:fileExtension | sizeInBytes | This will look for an email with 2 attachments. Note : Read ` MIGRATION - 2.2 . 0 . MD ` if you re using MailTrap","title":"the email has been sent and contains:"},{"location":"steps/#the-email-with-the-following-data-has-not-been-sent","text":"Checks if there is an email on the configured mailing service. This steps requires an array of filters to be applied to mailbox in order to find an email. Only currentUser , to_email , subject , html_body filters can be used in this step (attachments will be ignored). currentUser is a custom filter which checks if the user saved in this.currentUser variable is a recipient of an email. This is done by comparing email property of this.currentUser object to the one returned by email. You can do this like this: the email with the following data has not been sent: | to_email | t:example@yopmail.com | | html_body | t:some value | The number of columns is always 4, but depending form a filter you have to use all of them or only some. You can use the same filter multiple times: the email has been sent and contains: | html_body | t:some value | | html_body | t:some other value | Note : Read ` MIGRATION - 2.2 . 0 . MD ` if you re using MailTrap","title":"the email with the following data has not been sent:"},{"location":"steps/#files","text":"","title":"Files"},{"location":"steps/#the-file-filename-should-be-downloaded","text":"Checks if a file with name :fileName was downloaded. This step does not support matchers or regular expressions, so the name must be exact match. However you can use variable store here. Let's assume there is a variable myFile with a value super-file in variable store. You can write the file \"v:myFile.zip\" should be downloaded to check if a file super-file.zip was downloaded.","title":"the file \":fileName\" should be downloaded"},{"location":"steps/#the-file-filename-contains-table-data-stored-under-variablename-variable","text":"This step allows you to compare an xls/xlsx file :fileName with an existing data stored under :variableName variable. The data under :variableName must be an array of objects representing each row of file.","title":"the file \":fileName\" contains table data stored under \":variableName\" variable"},{"location":"steps/#generators","text":"","title":"Generators"},{"location":"steps/#i-generate-random-generatorparamparam-as-variablename","text":"Allows to generate a random value using the generator specified by :generator:param:param . The generator must be defined inside the any of the generators directories specified in kakunin.conf.js file default: generators . If the generator exists, then the value will be saved under the :variableName and can be accessed by: steps using variable store by calling variableStore.getVariableValue(:variableName) by using variable store transformer on supported steps v:variableName","title":"I generate random \":generator:param:param\" as \":variableName\""},{"location":"steps/#debug","text":"","title":"Debug"},{"location":"steps/#i-wait-for-seconds-seconds","text":"Waits with execution of next step for an amount provided by parameter :seconds .","title":"I wait for \":seconds\" seconds"},{"location":"steps/#i-start-performance-monitor-mode","text":"It starts performance monitor mode. Keep in mind that REST API must be started on the port which must configured in kakunin.conf.js - serverPort: 8887 . More details can be found in documentation file performance-testing.md .","title":"I start performance monitor mode"},{"location":"steps/#i-save-performance-report-file-as-filename","text":"It saves .har file with a name fileName in reports/performance catalog. For example: exampleReport-1511470954552.har Data is generated during the test - network tab in Chrome Chrome console. Keep in mind: I start performance monitor mode must be used before this step browserMob.port must be configured in kakunin.conf.js browserMob.host must be configured in kakunin.conf.js More details can be found in documentation file performance-testing.md .","title":"I save performance report file as \"fileName\""},{"location":"steps/#the-requests-should-take-a-maximum-of-maxtiming-milliseconds","text":"It compares every TTFB timing value from previously saved .har report with a maxTiming value. Slow requests are listed in your terminal in red colour. Keep in mind that I start performance monitor mode and I save performance report file as \"fileName\" steps must be executed before this one!","title":"the requests should take a maximum of \"maxTiming\" milliseconds"},{"location":"transformers/","text":"Transformers allow you to transform values passed to form steps. For example a select requires to pass a value /options/1b30f17e-e445-4d28-a30c-dedad95829ab . This one is quite unreadable, but with the help of transformers you are able to write it like this: d:options:someOptionName . In real-life example it will look similar to: I fill the myForm form with: | inputElement | d:someDictionary:someKey | | textareaElement | g:someGenerator | | radioElement | v:someVariableName | | checkboxElement | standard value | There are 3 types of built-in transformers: Dictionaries Dictionaries allows you to transform a value A to value B using a simple key- value transformation. You can run a dictionary transformer by providing dictionary prefix d: , specifying the dictionary name and key that should be used as a value provider. For example: d:myDictionaryName:myDictionaryKey this example assumes that there is a dictionary that supports name myDictionaryName and it has myDictionarKey key. You can read about dictionaries in Extending Kakunin section. Generators Generators allows you to generate a value by using a specified generator. This can be done by: g:generatorName . If a generator supports parameters then you can specify them by: g:generatorName:param1:param2:...:paramN You can read more about generators in Extending Kakunin section. Variable store Variable store allows you to fill the form with a value that was saved in previous steps of current running scenario. This can be done by: v:variableName You can read more about variable store in Extending Kakunin section","title":"Transformers"},{"location":"transformers/#dictionaries","text":"Dictionaries allows you to transform a value A to value B using a simple key- value transformation. You can run a dictionary transformer by providing dictionary prefix d: , specifying the dictionary name and key that should be used as a value provider. For example: d:myDictionaryName:myDictionaryKey this example assumes that there is a dictionary that supports name myDictionaryName and it has myDictionarKey key. You can read about dictionaries in Extending Kakunin section.","title":"Dictionaries"},{"location":"transformers/#generators","text":"Generators allows you to generate a value by using a specified generator. This can be done by: g:generatorName . If a generator supports parameters then you can specify them by: g:generatorName:param1:param2:...:paramN You can read more about generators in Extending Kakunin section.","title":"Generators"},{"location":"transformers/#variable-store","text":"Variable store allows you to fill the form with a value that was saved in previous steps of current running scenario. This can be done by: v:variableName You can read more about variable store in Extending Kakunin section","title":"Variable store"}]}